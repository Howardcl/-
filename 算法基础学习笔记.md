只有当输入超过100万时，才会必须要用scanf，否则用cin没什么区别。

new运算符返回的是新开辟类型的地址。故赋值号前都是类型的指针。new是在堆区开辟的。

## 时间复杂度
  时间复杂度往往只是定性描述，即不需要算出来具体数值。仅需要有大体的估算结果（有点像高数中的极限，仅考虑n趋近于正无穷时的情况）。下面给出几种常见时间复杂度的代码。
  ```c++
#include<iostream>
using namespace std;
int n,ans;
int main(){
	cin>>n;
	//O(1)和数据输入规模无关
	for(int i=0;i<9;++i)
		ans+=n;
	
	//O(logn)一般默认底数是2（就算不是也可以用指数换底公式换成2）
	for(int i=n;i;i/=2)
		ans+=n;
	
	//O(√n)
	for(int i=1;i*i<n;++i)
		ans+=n;
	
	//O(n)线性时间复杂度
	for(int i=0;i<n;++i)
		ans+=n;
	
	//O(n^2)
	for(int i=1;i<n;++i)
		for(int j=i+1;j<n;++j)
			ans+=n;
	
	return 0; 
}
  ```
此外，还有O(n!)（阶乘级）、O(C^n)（指数级）等时间复杂度。很显然，在大规模数据下这种复杂度的算法是不可行的，因此应注意规避此类算法。
 **由以上，计算出的时间复杂度为10^8级别以下，则在可接受范围之内。**


## 空间复杂度
可用sizeof(类型名或该类型的变量名)查看占用字节数。常用类型包括：

        int：32位二进制，2^31-1=2147483647（约10^9）可用于判断是否需要使用更大类型（如long long类型）的变量存储数据。
    
        long long：64位二进制，2^63-1（约10^18） 
    
        char：8位二进制
    
        bool：8位二进制，但仅有0和1 
    
        double：64位二进制，需要注意的是，当将一个十进制小数转化为二进制小数时，可能会转化为一个无限循环小数。如：0.5、 0.25、 0.125转化为二进制分别为0.1、 0.01、 0.001，但十进制的0.3很明显不能由二进制拼出。可运行如下代码进行测试：
```c++
#include<iostream>
using namespace std;
double n,ans;
int main(){
    
    cout<<(0.1+0.2==0.3);//结果为0，说明等式不成立
    //因此若想判断两小数运算相等，最好用 0.1+0.2-0.3<=1e-7 的方式
    
    return 0;
}
```

1. **内联函数**

在C++中我们通常定义以下函数来求两个整数的最大值：

代码如下:

``` c++
int max(int a, int b)
{
 return a > b ? a : b;
}
```

为这么一个小的操作定义一个函数的好处有：

① 阅读和理解函数 max 的调用，要比读一条等价的条件表达式并解释它的含义要容易得多

② 如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多

③ 使用函数可以确保统一的行为，每个[测试](http://lib.csdn.net/base/softwaretest)都保证以相同的方式实现

④ 函数可以重用，不必为其他应用程序重写代码

虽然有这么多好处，但是写成函数有一个潜在的缺点：**==调用函数比求解等价表达式要慢得多。==**在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行

**C++中支持内联函数，其目的是为了提高函数的执行效率**，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：

```c++
inline int max(int a, int b)
{
 return a > b ? a : b;
}
```

则调用： `cout<<max(a, b)<<endl;`
在编译时展开为： `cout<<(a > b ? a : b)<<endl;`

从而消除了把 max写成函数的额外执行开销。

2. **内联函数和宏**

无论是《Effective C++》中的 “Prefer consts，enums，and inlines to #defines” 条款，还是《高质量程序设计指南——C++/[C语言](http://lib.csdn.net/base/c)》中的“用函数内联取代宏”，宏在C++中基本是被废了，在书《高质量程序设计指南——C++/C语言》中这样解释到：

3. **将内联函数放入头文件**

关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。

如下风格的函数 Foo 不能成为内联函数：

代码如下:

```c++
inline void Foo(int x, int y);  // inline 仅与函数声明放在一起  
void Foo(int x, int y)
{
 ...
} 
```

而如下风格的函数 Foo 则成为内联函数：

代码如下:

```c++
void Foo(int x, int y);  
inline void Foo(int x, int y)  // inline 与函数定义体放在一起
{
 ...
} 
```

所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：**声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。**

**定义在类声明之中的成员函数将自动地成为内联函数**，例如：

代码如下:

```c++
class A
{ 
public:
 void Foo(int x, int y) { ... }  // 自动地成为内联函数 
} 
```

但是编译器是否将它真正内联则要看 Foo函数如何定义

**内联函数应该在头文件中定义，**这一点不同于其他函数。编译器在调用内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。

当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。

2.**const的作用**

（1）const用于定义常量：const定义的常量编译器可以对其进行数据静态类型安全检查。

（2）const修饰函数形式参数：当输入参数为用户自定义类型和抽象数据类型时，应该将值传递改为const &传递，可以提高效率。比较下面两段代码：
```c++
void fun(A a);
void fun(A const &a);
```
第一个函数效率低。函数体内产生A类型的临时对象用于复制参数a，临时对象的构造、复制、析构过程都将消耗时间。而第二个函数提高了效率。用**引用传递不需要产生临时对象，节省了临时对象的构造、复制、析构过程消耗的时间**。但是只有引用有可能会改变a，所以加const。

（3）const修饰函数的返回值：如给指针传递的函数返回值加const，则返回值不能被直接修改，且该返回值只能被赋值给加const修饰的同类型的指针，例如：
```c++
const char *GetChar(void){};
char *ch = GetChar();     //error
const char *ch = GetChar();   //correct
```
（4）const修饰类的成员函数（函数定义体）：任何不会修改数据成员的函数都应用const修饰，这样，当不小心修改了数据成员或调用了非const成员函数时，编译器都会报错。const修饰类的成员函数形式为：
```c++
int GetCount(void) const;//注意const放的位置（放在最后）
```
（5）当const修饰函数形参时，顶层const会被忽略，即：
```c++
void fcn(const int i){/*fcn能够读取i，但不能修改i*/}
void fcn(int i){/*.....*/}//错误：重复定义了fcn
```

要尽量使用常量引用

（6）数组形参和const
# 第一讲 基础算法

## 1.1 排序(总结一下：时间复杂度 稳定性 排序思想)

排序主要讲==快速排序==和==归并排序==。主要理解并背过代码模板，要达到能到快速把代码模板默写出来。这个工作很重要。然后用题目来检验模板是否记忆的很好，刷题大概可以重复3-5次。

### 1.1.1 快速排序

主要思想是基于分治。算法流程如下：

1. **确定分界点**
2. **调整区间**
3. **递归处理左右两段**

其中调整区间所用的思想是双指针：两端指针分别向中间移动，直到不满足``q[i]<x``,``q[j]>x``时停止移动，当双指针都停止移动时，交换此时它们所指向的值``swap``，然后继续移动，直到双指针相遇``i=j``。



![image-20211116093224801](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211116093224801.png)

**==快排代码模板：==**

```c++
//注意边界问题，分界点如果选取q[l]或q[r]，都有可能产生死循环，如果选中间则不会
#include <iostream>

using namespace std;

const int N = 100010;

int q[N];

void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;//递归终止条件

    int i = l - 1, j = r + 1, x = q[l + r >> 1];//确定分界点 分界点为数组中具体的值
    while (i < j)//调整区间
    {
        do i ++ ; while (q[i] < x);//如果跳出循环，说明q[i]>=x
        do j -- ; while (q[j] > x);//如果跳出循环，说明q[j]<=x
        if (i < j) swap(q[i], q[j]);
    }

    quick_sort(q, l, j);//递归处理左右两段
    quick_sort(q, j + 1, r);
}

int main()
{
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    quick_sort(q, 0, n - 1);

    for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);

    return 0;
}

```

### 1.1.2 归并排序

归并排序的思想也是分治，与快排不同之处是，快排选的是某个点的值，而归并是以数组中间点的位置来分。

算法流程如下：

**1.确定分界点``mid=(l+r)/2``，数组分为``left``,``right``；**

**2.对左右两边都进行递归排序,得到两个有序数组；**

**3.对两个有序数组进行合并，思路是双指针算法，用两个指针分别指向两个有序数组的最小值，然后对这两个最小值进行比较，最小的值放在``res``数组中，直到有一个指针到达尽头，另一个数组剩下的部分添加到队尾即可。**

![image-20211116111226788](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211116111226788.png)

![image-20211116111604958](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211116111604958.png)

时间复杂度：每次遍历长度为n，通过递归一共有``log_n``层（因为要划分到长度为1的有序数组），所以总的时间复杂度是``O(nlogn)``。

![image-20211116112734735](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211116112734735.png)

**==归并排序代码模板：==**

```c++
#include<iostream>

using namespace std;

const int N = 100010;
int n;
int q[N],temp[N];

void merge_sort(int q[],int l,int r)
{
    if(l >= r) return; //递归终止条件
    int mid = l+r >> 1; //分界点
    merge_sort(q,l,mid),merge_sort(q,mid + 1,r); //递归左右数组
    
    int k = 0,i = l,j = mid + 1;  //合并两个有序数组到temp数组
    while(i <= mid && j <= r)
    {
        if(q[i] <= q[j]) temp[k++] = q[i++];
        else temp[k++] = q[j++];
    }
    while(i <= mid) temp[k++] = q[i++];//两个数组中还剩下的部分，加到temp数组后面
    while(j <= r) temp[k++] = q[j++];
    
    for(int i = l,j = 0;i <= r;i++,j++) q[i] = temp[j]; //从temp数组复制到原数组
}

int main()
{
    scanf("%d",&n);
    for(int i = 0;i < n;i++) scanf("%d",&q[i]);
    
    merge_sort(q,0,n-1);
    
    for(int i = 0;i < n;i++) printf("%d ",q[i]);
    return 0;
}
```

## 1.2 二分查找(考)

简单定义：在一个单调有序的集合中查找元素，每次将集合分为左右两部分，判断解在哪个部分中并调整集合上下界，重复直到找到目标元素。

时间复杂度：O (logn)，优于直接顺序查找O(n)

主要讲整数二分和浮点数二分。

### 1.2.1 整数二分

二分的本质：并不是单调性，如果有单调性就一定可以二分，可以二分的题目不一定非得有单调性，如果没有单调性，也有可能可以二分。**二分的本质是边界**，给定我们一个区间，**在这个区间上定义某种性质，这种性质在右半边满足，在左半边不满足**，如果可以找到这样一种性质，将区间一分为二的话，那二分就可以寻找这个性质的边界。（例如下图的两点）

![image-20211118194721560](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211118194721560.png)

**==算法思路==**：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。当想要的target在左半区间时，就要更新右边界，即``r=mid``,所以相应地``l =mid + 1``,当target在右半区间时，需要更新左边界,即``l = mid ``,相应的``r = mid - 1``.

==二分模板==一共有两个，分别适用于不同情况。

**版本1**
当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。

```c++
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

**版本2**

当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，==此时为了防止死循环，计算mid时需要加1。==

```c++
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```



### 1.2.2 浮点数二分

浮点数二分就没有边界问题了，不用考虑+1的问题。思路：直接二分，选取想要的区间，更新边界值等于mid即可。

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```



## 1.3 高精度

一般考四种

1.两个比较大的整数相加，``A+B``，位数在$10^6$以内，即整数的长度在1000000以内。

2.两个比较大的整数相减``A-B``

3.一个大整数乘小整数`A*b`

4.``A/b``,求商和余

### 1.3.1 高精度加法

**算法流程**

1.首先是大整数的存储，==用int变量是存不下来的，其实是把大整数的每一位存到数组里面去==。存的时候就有问题了，是高位在前还是低位在前呢？

一般把个位（低位）放在数组首位，因为进位的时候，往数组尾端插入是最容易的。即==个位放首位，高位放队尾。==

2.然后是用数组模拟加法。如果A还有，则加A，B还有，则加B

![image-20211119192201333](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211119192201333.png)

**高精度加法-算法模板**

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )//从个位开始加
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;//进位
    }

    if (t) C.push_back(t);
    return C;
}
```

### 1.3.2 高精度减法

![image-20211119194243148](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211119194243148.png)

**高精度减法-算法模板**

```c++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )//从个位开始减
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);//+10 是因为t可能减不到，是负的
        if (t < 0) t = 1;//意味着借位了，则计算高位的A[i]是要减去1
        else t = 0;//否则没有借位，正常减
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();//去掉前导0（即去掉数组高位-后面的0）
    return C;
}
```

### 1.3.3 高精度乘法

**高精度乘低精度 —— 模板**

```C++
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;//进位
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);//取出个位
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```

### 1.3.4 高精度除法

前面的加减乘都是从低位开始算，但除法是从高位开始算的。除法得到商和余

```c++
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];//中间量的余数，用于下一步的除法
        C.push_back(r / b);//把商加进去
        r %= b;//每一步剩下的余数
    }
    reverse(C.begin(), C.end());//因为前面的除法步骤是把高位数放在数组的低位的，这与我们要求数组尾放高位是相反的，故需要逆转
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

## 1.4 前缀和差分

​	前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。

**前缀和思维导图**

![image-20211128150825268](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128150825268.png)

### 1.4.1 一维前缀和

前缀和数组：$S_i=a_1+a_2+...+a_i$

==作用：快速求出原数组中一段数的和。可以用一次运算算出任意一段数的和。==

![image-20211122111917173](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211122111917173.png)

如何算$S_i$，$S_i=S_{i-1}+a_i$。

**一维前缀和 —— 模板**

```c++
S[i] = a[1] + a[2] + ... a[i]
S[i] = S[i-1]+a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

### 1.4.2 二维前缀和

$S_{ij}$表示左上角所有元素的和。

![image-20211128142140909](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128142140909.png)

```C++
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

### 1.4.3 一维差分

**差分思维导图：**

![image-20211128150932746](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128150932746.png)

类似于数学中的求导和积分，**差分可以看成前缀和的逆运算**。

差分数组：首先给定一个原数组``a：a[1], a[2], a[3],,,,,, a[n]``;

然后我们构造一个数组``b：b[1],b[2],b[3],,,,,, b[i]``;使得 ``a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]``

也就是说，**a数组是b数组的前缀和数组**，**反过来我们把b数组叫做a数组的差分数组**。换句话说，每一个a[i]都是b数组中从头开始的一段区间和。考虑如何构造差分b数组？最为直接的方法:

![image-20211128145716120](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128145716120.png)

我们只要有`b`数组，通过前缀和运算，就可以在`O(n)` 的时间内得到`a`数组 。

![image-20220320180406118](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20220320180406118.png)

**代码模板**

```c++
#include<iostream>

using namespace std;

const int N = 1e6 + 10;

int n,m;
int a[N],b[N];

int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++) 
    {
        scanf("%d",&a[i]);
        b[i] = a[i] - a[i-1];//构建差分数组
    } 

    int l,r,c;
    while(m--)
    {
        cin >> l >> r >> c;
        b[l] += c;  //将序列中[l, r]之间的每个数都加上c
        b[r+1] -= c;
    }
    for(int i = 1;i <= n;i++)
    {
        a[i] = b[i] + a[i-1]; //前缀和运算,根据差分数组更新原数组
        printf("%d ",a[i]);
    }
    return 0;
}
```



### 1.4.4 二维差分		

![	](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128154758230.png)

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int a[N][N],b[N][N];

void insert(int x1,int y1,int x2,int y2,int c)
{
    b[x1][y1] += c;
    b[x1][y2+1] -= c;
    b[x2+1][y1] -= c;
    b[x2+1][y2+1] += c;
}
int main()
{
    int n,m,q;
    cin >> n >> m >> q;
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= m;j++)
        {
            scanf("%d",&a[i][j]);
            insert(i,j,i,j,a[i][j]);//构建差分数组
        }
    while(q--)
    {
        int x1,y1,x2,y2,c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1,y1,x2,y2,c);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            a[i][j] = b[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];//根据差分数组更新原数组
        }
    }
    for(int i = 1;i <= n;i++)
    {   
        for(int j = 1;j <= m;j++)
        {   
            printf("%d ",a[i][j]);
        }
        cout << endl;
    }
    return 0;
}
```



## 1.5 双指针算法(考)
**双指针的核心思想**：
先想一下暴力做法是什么，在挖掘一些性质，使得问题的时间复杂度降低。
**双指针模板**
```c++
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```
###最长连续不重复子序列
####题目描述
给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
**输入格式**
第一行包含整数 n。
第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。

**输出格式**
共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
数据范围
```1≤n≤105```
**输入样例**
5
1 2 2 3 5
**输出样例**
3

思路:
首先是i枚举数组中的每一个位置，在i的某个位置中，j严格<=i,如果出现重复的元素，那么一定是枚举到的当前的a[i]，于是j指针可以开始移动了,只要这个重复的数不从这个"区间"中剔除，那么j就一直往右移动，最多是与i重合，那么while()停止。
抽象成理解的角度就为:
每次维护一个区间，一但出现重复的数，此时将该区间缩减(区间更新)，使区间的头为与a[i](当前的数)重复的第一个数的后面,这样可以就有最优解。


## 1.6 位运算
**模板**
```
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n & -n
```
## 1.7 离散化
**离散化模板**
```c++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

**模板题：区间和**

**题目描述**

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。
现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。
接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含两个整数 x 和 c。

再接下来 m 行，每行包含两个整数 l 和 r。


**输出格式**

共 m 行，每行输出一个询问中所求的区间内数字和。

**数据范围**
```
−109≤x≤109,
1≤n,m≤105,
−109≤l≤r≤109,
−10000≤c≤10000
```
**输入样例**
```
3 3
1 2
3 6
7 5
1 3
4 6
7 8
```
输出样例
```
8
0
5
```
**思路：如果是较小的数组范围，那可以直接用前缀和。**
```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

const int N = 3e5+10;
typedef pair<int,int> PII;

vector<int> alls;//把需要离散化的下标加进这个数组

vector<PII> add,query;
int a[N],s[N];

int find(int x)
{
    int l = 0,r = alls.size() - 1;
    while(l < r)
    {
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}

int main()
{
    int n,m;
    cin >> n >> m;
    int x,c;
    for(int i = 0;i < n;i++)
    {
        cin >> x >> c;
        add.push_back({x,c});
        alls.push_back(x);//存储该下标，要把下标x离散化
    }
    for(int i = 0;i < m;i++)
    {
        int l,r;
        cin >> l >> r;
        query.push_back({l,r});//

        alls.push_back(l);
        alls.push_back(r);
    }
    //去重
    sort(alls.begin(),alls.end());
    alls.erase(unique(alls.begin(),alls.end()),alls.end());

    for(auto item:add)
    {
        int x = find(item.first);
        a[x]  += item.second;
    }
    //预处理前缀和
    for(int i = 1;i <= alls.size();i++) s[i] = s[i-1] + a[i];

    //处理询问
    for(auto item:query)
    {
        int l = find(item.first),r = find(item.second);
        cout << s[r] - s[l-1] << endl;//输出区间和 
    }
    return 0;
}
```

## 1.8 区间合并	
**合并模板**
```c++
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

**模板题-区间合并**：

给定 n 个区间 [li,ri]，要求合并所有有交集的区间。

注意如果在端点处相交，也算有交集。

输出合并完成后的区间个数。

例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。

**输入格式**

第一行包含整数 n。
接下来 n 行，每行包含两个整数 l 和 r。

**输出格式**

共一行，包含一个整数，表示合并区间完成后的区间个数。

**数据范围**
```
1≤n≤100000,
−10^9≤li≤ri≤10^9
```
**输入样例**：
```
5
1 2
2 4
5 6
7 8
7 9
```
**输出样例**：
```
3
```
**流程**：

1.按照左端点排序，按照左端点从小到大的顺序依次扫描。
2.只有三种关系，merge中就是处理这三种关系去合并。
![20220326204500](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220326204500.png)


# 第二讲 数据结构
主要讲如何用数组去模拟链表、栈与队列。
为什么需要用数组去模拟链表呢？
因为new操作非常慢，一般在笔试题中，链表节点都是十万以上级别，单单是把这100000个节点new出来就已经超时了。
![20220327114630](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220327114630.png)
## 2.1 单链表（定义）
单链表用的最多的就是邻接表，
```C++
//new方式的定义如下：
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) { val = v;}
    ListNode(int v = 0) { val = v;}
    ListNode(int v, ListNode* n) { val = v, next = n; }
};

ListNode* head = new ListNode(0);
ListNode* head = new ListNode();
// node1 是一个已经定义好的节点
ListNode* head = new ListNode(0, node1);   // head -> node1
```
**单链表模板**
```c++
//head表示头结点的下标
//e[i] 表示节点i的值
//ne[i] 表示节点i的next指针是多少
//idx 存储当前已经用到了哪个点
int head,e[N],ne[N],idx;

//初始化
void init()
{
    head = -1;
    idx = 0;
}

//将x插到头节点
void add_to_head(int x)
{
    e[idx] = x;//存储x这个值
    ne[idx] = head;//把x节点的指针指向原来head指向的值
    head = idx;//把head指向idx
    idx++; //idx已经被用过了，移到下一位
}
//将x这个点插到下标是k的这个点后面
void add(int k,int x)
{
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}
//将下标是k的点后面的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];
}
```
## 2.2 双链表
**模板**
```c++
int e[N],l[N],r[N],idx;

void init()
{
    //0表示第一个点，1表示第二个点
    r[0] = 1,l[1] = 0;
    idx = 2;
}

//双链表的插入,在下标k的右边插入
//如果想在k的左边插入，就是add(l[k],x),k的左边，就是l[k]的右边
void add(int k,int x)
{
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
}

//删除操作，让这个点的左边节点的右边直接等于这个点的右边,
// 让这个点的右边节点的左边直接等于这个点的左边
void remove(int k)
{
    r[l(k)] = r(k);
    l[r(k)] = l(k);
}
```

## 2.3 栈
栈：先进后出
```c++
// ***************************栈
//stk为栈，tt为栈顶下标
int stk[N],tt;
//插入
stk[++tt] = x;
// 从栈顶弹出一个数
tt -- ;
//判空
if(tt > 0 ) not empty;
else empty;
//栈顶
stk[tt];
```


## 2.4 队列
1.**普通队列**
```c++
//*****************************队列
//hh队头，tt队尾，在队尾插入元素，在队头弹出元素
int q[N],hh,tt = -1;

//插入
q[++tt] = x;
//弹出,把队头的指针往后移动一位，意味着队头弹出了一位
hh ++;
//判断非空
if(hh <= tt) not empty;
else empty;
//取出队头,队尾元素
q[hh],q[tt];
```
2.**循环队列**
```c++
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```

## 2.5 单调栈
**模板题目**
```c++
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
```c++
#include<iostream>

using namespace std;

const int N = 1e5+10;
int a[N],n;
int stk[N],tt;
/*
//朴素(暴力)做法
for(int i = 0;i < n;i++)//先枚举每个i
    for(int j = i - 1;j >= 0;j--)
        if(a[i] > a[j]) 
        { 
            cout << a[j];
            break;
        }
        else cout << "-1" << ' ';
*/
int main()
{
    ios::sync_with_stdio(false);//加速读入，大概加速100-200ms
    scanf("%d",&n);//scanf printf大概比cin printf快500ms
    for(int i = 0;i < n;i++)
    {
        int x;
        scanf("%d",&x);
        while(tt && stk[tt] >= x) tt--;//满足这个性质(栈不为空且栈顶元素大于插入的i)，则栈顶元素永远不会被用到
        if(tt) printf("%d ",stk[tt]);//如果不满足上面的性质，那栈顶元素就是离i最近且最小的数
        else printf("-1 ");
        
        stk[ ++ tt] = x;//把x插入到栈中
    }
    return 0;
}
```


## 2.6 单调队列--滑动窗口


**凡是用单调队列的题，基本上都是滑动窗口。**

**单调队列使用双端队列实现，双端队列的优点在与既可以从队首删除，也可以从队尾删除元素。**

最大值：我们定义一个双端队列，当队列不空时，每次窗口移动后，将新元素与队列中的元素从后往前比较，将队列中比新元素小的元素删除（只要队列中的元素还在窗口内，且比新元素小，则窗口中最大值必不可能为队列中的元素），在此操作之前同样要将窗口移动后队列中已不在窗口的元素出列，那么每次操作之后队列的首元素既是窗口中的最大值。

最小值：同理将队列中比新元素大的全部删除即可。

时间复杂度：每个元素出队入队一次，出队一次，所以复杂度为O(n)。



**模板题**--**滑动窗口**

给定一个大小为 n≤$10^6$的数组。

有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。

你只能在窗口中看到 k 个数字。

每次滑动窗口向右移动一个位置。

以下是一个例子：

该数组为 `[1 3 -1 -3 5 3 6 7]`，k 为 33。

| 窗口位置            | 最小值 | 最大值 |
| :------------------ | :----- | :----- |
| [1 3 -1] -3 5 3 6 7 | -1     | 3      |
| 1 [3 -1 -3] 5 3 6 7 | -3     | 3      |
| 1 3 [-1 -3 5] 3 6 7 | -3     | 5      |
| 1 3 -1 [-3 5 3] 6 7 | -3     | 5      |
| 1 3 -1 -3 [5 3 6] 7 | 3      | 6      |
| 1 3 -1 -3 5 [3 6 7] | 3      | 7      |

你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

**输入格式**

输入包含两行。

第一行包含两个整数 n和 k，分别代表数组长度和滑动窗口的长度。

第二行有 n 个整数，代表数组的具体数值。

**输出格式**

输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

代码：

```c++
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

## 2.7 KMP算法--字符串匹配算法
**模板题-KMP字符串**

**题目描述**：

给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。
模板串 P 在模式串 S 中多次作为子串出现。求出模板串 P 在模式串 S 中所有出现的位置的起始下标。

**输入格式**

第一行输入整数 N，表示字符串 P 的长度。

第二行输入字符串 P。

第三行输入整数 M，表示字符串 S 的长度。

第四行输入字符串 S。

**输出格式**

共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。

**数据范围**
```
1≤N≤10^5
1≤M≤10^6
```
**输入样例**：
```
3
aba
5
ababa
```

**输出样例**：
```
0 2
```
朴素做法如下：
![20220328160404](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328160404.png)
**对于模板串这个数组，要预处理出来，我的后缀和前缀相等，这个相等的前缀和后缀最大长度是多少。这就是KMP算法中next[i]数组的含义。**    
![20220328161651](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328161651.png)
![20220328164055](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328164055.png)
![20220328164859](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328164859.png)
![20220328173003](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328173003.png)
![20220328172642](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328172642.png)

完整代码如下：

```c++
#include<iostream>

using namespace std;

const int N = 100010,M = 1000010;

int n,m;
int ne[N];
char p[N],s[M];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;
    //求next过程
    for(int i = 2,j = 0;i <= n;i++)
    {
        while(j && p[i] != p[j+1]) j = ne[j];
        if(p[i] == p[j+1]) j++;
        ne[i] = j;
    }
    //kmp匹配过程
    for(int i = 1,j = 0;i <= m;i++)
    {
        while(j && s[i] != p[j+1]) j = ne[j];
        if(s[i] == p[j+1]) j++;
        if(j == n) 
        {
            //匹配成功,输出起始位置,因为输出下标从0开始计数，所以最后要-1
            printf("%d ",i - n + 1 - 1);
            j = ne[j];//继续匹配下一个子串
        }
    }
    return 0;
}
```
## 2.8 Tire树--字符串集合查询
**Tire树：** 用来高效地存储和查找字符串集合的数据结构。

一般用到Tire树的题目，要么全是大写字母，要么全是小写字母，要么全是0和1,字母的类型不会特别多。

Tire树的存储如下：红星代表有单词的结尾。
![20220328202527](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328202527.png)
Tire树的查找：先从根节点往下查找，如果找到最后正好存在一个结尾标记，那么代表Tire树中有这个字符串。



**题目：Tire字符串统计**

维护一个字符串集合，支持两种操作：

1. `I x` 向集合中插入一个字符串 x；
2. `Q x` 询问一个字符串在集合中出现了多少次。

共有 N 个操作，输入的字符串总长度不超过 $10^5$，字符串仅包含小写英文字母。

**输入格式**

第一行包含整数 N，表示操作数。

接下来 N 行，每行包含一个操作指令，指令为 `I x` 或 `Q x` 中的一种。

**输出格式**

对于每个询问指令 `Q x`，都要输出一个整数作为结果，表示 x在集合中出现的次数。

每个结果占一行。

**数据范围**

1≤N≤2∗$10^4$

输入样例：

```
5
I abc
Q abc
Q ab
I ab
Q ab
```

**输出样例**：

```
1
0
1
```



**代码模板**
```c++
//son存的是每一个点的所有子节点，cnt存的是以当前这个点结尾的单词有多少个，
//idx存的是当前用到的下标，下标是0的点，既是根节点，又是空节点。
int son[N][26],cnt[N],idx;
//插入字符串
void insert(char str[])
{
    int p = 0;
    for(int i = 0;str[i];i++)
    {
        int u = str[i] - 'a';
        if(!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
//查询字符串
int query(char str[])
{
    int p = 0;
    for(int i = 0;str[i];i++)
    {
        int u = str[i] - 'a';
        if(!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

## 2.9 并查集--合并集合，查询集合
![20220329101124](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329101124.png)
![20220329122853](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329122853.png)
基本原理：首先用树的形式维护所有的集合。每个集合用一颗树表示。
集合的编号就是树根的编号，我们对每一个节点都存储一下他的父节点，p[x]表示x的父节点。因此判断元素属于哪个集合时，只需要不停的向上找，找到根节点，就可以判断属于哪个集合。

问题1:如何判断树根:if(p[x] == x)

问题2:如何求x的集合编号：while(p[x] != x) x = p[x];//只要x不是树根，就一直往上走。

问题3:如何合并两个集合：加一条边即可。假设px是x的集合编号，py是y的集合编号。令p[x] = y即可;
![20220329104429](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329104429.png)
现在时间复杂度还是比较高的，主要原因还是因为找树根的过程太慢。怎样加速呢？路径压缩优化。

**朴素并查集模板如下：**
```c++
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
```

如果想要动态的知道当前集合元素的个数该怎么做？
**模板题-合并集合**

一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。

现在要进行 m 个操作，操作共有两种：

1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2. `Q a b`，询问编号为 a和 b 的两个数是否在同一个集合中；

**输入格式**

第一行输入整数 n 和m。

接下来 m 行，每行包含一个操作指令，指令为 `M a b` 或 `Q a b` 中的一种。

**输出格式**

对于每个询问指令 `Q a b`，都要输出一个结果，如果 aa 和 bb 在同一集合内，则输出 `Yes`，否则输出 `No`。

每个结果占一行。

**数据范围**

1≤n,m≤105

**输入样例**：

```
4 5
M 1 2
M 3 4
Q 1 2
Q 1 3
Q 3 4
```

**输出样例**：

```
Yes
No
Yes
```

```C++
#include<iostream>

using namespace std;

const int N = 1e5+10;

int p[N];
int n,m;

int find(int x)//找到x属于哪个集合,即返回x的祖宗节点+路径压缩
{
    //并查集的核心操作，如果说x不是根节点的话，
    // 就让它的父节点等于祖宗节点，然后返回父节点即可。
    if(p[x] != x) p[x] = find(p[x]); 
    return p[x];
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 1;i <= n;i++) p[i] = i;
    while(m--)
    {
        char op[2];//如果用scanf来读入字母的话，建议还是读成字符串的形式，因为scanf的%c会读入空格等，比较奇怪
        int a,b;
        scanf("%s%d%d",&op,&a,&b);
        if(op[0] == 'M') p[find(a)] = find(b);//合并操作，让b的祖宗节点直接成为a的祖宗节点的父节点
        else 
        {
            if(find(a) == find(b)) puts("Yes");
            else puts("No");
        }
        
    }
}
```



## 2.10 堆
如何手写一个堆？堆是维护一个数据集合。堆是完全二叉树。除了最后一层节点，所有节点都是非空的。最后一层节点从左到右依次排列的。堆满足小根堆的定义：每一个点的值小于等于左右儿子。那么根节点就是最小值。

**堆要支持哪些操作？**

**1.插入一个数**

**2.求这个集合当中的最小值**

**3.删除最小值（用最后一个点覆盖掉根节点，去掉最后一个点，down一遍)**

**4.删除任意一个元素（后面这两个操作STL中的堆无法直接实现)(类似于删除最小值)**

**5.修改任意一个元素**

**用一个1维数组可以存下一个堆，根节点是1,左儿子是2x，右儿子是2x+1。**
![20220329130721](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329130721.png)

堆的操作：
1.down(x):往下调整。把一个节点往下移。如果把一个值变大了，就把他往下移。
2.up(x):往上调整。把一个节点往上移。如果把一个值变小了，就把他往上移。
刚才的这五个操作，完全可以由这两个操作实现。

![20220329132506](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329132506.png)

这里的下标是从1开始的，比较方便。因为从0开始，2*0=0。
**模板**
```c++
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置,p:下标，h:堆,表示从下标映射到堆。
// hp[k]存储堆中下标是k的点是第几个插入的，表示从堆映射到下标。
int h[N], ph[N], hp[N], Size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;//down操作的核心就是看一下这个点是不是3个点里面的最小值，用t来表示最小值的编号
    //判断是不是左儿子更小一些,如果左儿子更小一些，就让t等于左儿子。
    //如果右儿子更小一些，就让t等于右儿子
    if(u * 2 <= Size && heap[u*2] < heap[t]) t = u * 2;
    if(u * 2 + 1 <= Size && heap[u * 2 + 1] < heap[t]) t = u *2 + 1;
    if(u != t)//说明根节点不是最小的，根节点就要和最小的交换一下，然后递归处理
    {
        // swap(heap[u],heap[t]);
        heap_swap(u,t);
        down(t);
    }
}

void up(int u)
{
    //只要我有父节点，写成u/2,并且我的父节点比当前节点要大的话，就应该交换一下。
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u /= 2;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

## 2.11 哈希表

哈希表是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。

哈希表的一个重要问题就是如何解决映射冲突的问题。常用的有两种：开放地址法 和 链地址法。

哈希表的作用：把一个比较复杂的数据结构，映射到比较小的空间，映射到从0-N，N一般是1e5。N最好取质数。比如从$0-10^{-9}->0-10^5$。其实这个映射就是取模，取模N等同于映射到{0,N-1}.

![20220329161501](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329161501.png)

哈希函数怎么写？一般情况下是直接取模即可。就可以把大的值域映射出来。但是可能会有冲突，比如把两个不一样的数，映射成了同样的数。
![20220329164129](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329164129.png)

发生冲突的话要处理冲突，

**1.拉链法**：首先开一个一维数组，来存储所有的哈希值。如果有两个数是冲突的，那我就会在每个槽上，拉一条链，把这些数全部存下来。

![20220329164717](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329164717.png)

**在算法题里，哈希表一般只有添加和查询，没有删除。**

2.开放寻址法：只开一个一维数组，不用开链表。数组长度一般开输入的2-3倍。

那开放寻址法如何处理冲突？添加的话，如果求出来h(x) = k的话，先看数组的k位置上有没有被占用，如果被占用的话，顺移到下一位，直到找到第一个空位为止。

查找的话，如果当前坑位有人并且是x的话，就直接找到了，如果坑位有人但不是x的话，就继续看下一个坑位。如果当前坑位没人，说明x不存在。

删除的话，从前往后找，按照查找的方式来找x，不会把x真的删除，而是把x打一个标记。

哈希表的时间复杂度是O(1)的。

**一般哈希**-**模板**
```c++
(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;//这是为了处理余数是负数的情况。
        e[idx] = x;//以下三行为单链表的插入
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])//遍历哈希表元素,从h[k]开始，h[k]存的是链表头的下标
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```
### 字符串前缀哈希法

![20220330090946](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220330090946.png)

![20220329205325](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329205325.png)

把所有字符串的前缀映射成哈希值有什么好处？好处就是我们可以用字符串前缀哈希值计算出任意一个子串的哈希值。

**代码模板**
```c++
//思路：分别计算两个子串的哈希值，如果两个子串的哈希值相同，就认为这两个子串是相同的
//很多特别困难的字符串题目（需要思考很久用kmp来做的)，
// 总之，当我们需要快速判断两个字符串是否相等的时候，就都可以用字符串哈希来做
#include<iostream>

using namespace std;
typedef unsigned long long ULL;
const int N = 1e5+10,P = 131;
int n,m;
char str[N];
// h[i]前i个字符的hash值:预处理所有前缀的哈希
// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字
// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突
// 使用场景： 两个字符串的子串是否相同
//核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
//小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果
ULL h[N],p[N];// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

//计算子串 str[l ~ r] 的哈希值
ULL gets(int l,int r)
{
    return h[r] - h[l -1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d%s",&n,&m,str + 1);
    p[0] = 1;// 初始化
    //求字符串前缀的哈希值
    for(int i = 1;i <= n;i++)
    {
        p[i] = p[i - 1]*P;
        h[i] = h[i - 1] * P + str[i];//前缀和求整个字符串的哈希值
    }

    while(m --)
    {
        int l1,r1,l2,r2;
        cin >> l1 >> r1 >> l2 >> r2;
        if(gets(l1,r1) == gets(l2,r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

## 2.12 STL技巧简介

```c++
vector, 变长数组，倍增的思想//要尽量减少vector申请的次数，如果要申请n的空间，那么倍增次数是log(n),平均插入时间是O(1)
    size()  返回元素个数
    empty()  返回是否为空//size和empty函数是所有容器都有的
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []//支持随机寻址
    支持比较运算，按字典序

pair<int, int>//可以存储一个二元组
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，其实就是堆，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义方式：priority_queue<int> heap;
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

set/multiset
    insert()  插入一个数
    find()  查找一个数
    count()  返回某一个数的个数
    erase()
    (1) 输入是一个数x，删除所有x   O(k + logn)
    (2) 输入一个迭代器，删除这个迭代器
    lower_bound()/upper_bound()
    lower_bound(x)  返回大于等于x的最小的数的迭代器
    upper_bound(x)  返回大于x的最小的数的迭代器
    函数lower_bound(ForwardIterator first, ForwardIterator last, const T& val)
    在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置
	函数upper_bound()在first和last中的前闭后开区间进行二分查找，返回大于val的第一个元素位置。如果所有元素都小于val，则返回last的位置

    
map/multimap
    insert()  插入的数是一个pair
    erase()  输入的参数是pair或者迭代器
    find()
    []  注意multimap不支持此操作。 map可以像数组一样用，但时间复杂度是 O(logn)，不像数组是O(1);
	lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```

# 第三讲 搜索与图论

## 3.1 DFS与BFS

空间上DFS更占优势，但是BFS具有最短性。
![20220330150705](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220330150705.png)

凡是算法思路比较奇怪的，需要回溯的，都是用DFS。凡是需要最短，都用BFS。

**n皇后问题**-**DFS代码模板**
```c++
#include <iostream>

using namespace std;

const int N = 20;
char g[N][N];
int n;
bool col[N],dg[N],udg[N];//分别代表列，对角线，反对角线

void dfs(int u)
{
    if(u == n)//到达最后一层，输出排序方案
    {
        for(int i = 0; i < n;i++) puts(g[i]);
        puts("");
        return;
    }
    //对n个位置按行搜索
    for(int i = 0;i < n;i++)
    {
        // 剪枝(对于不满足要求的点，不再继续往下搜索)  
        // udg[n - u + i]，+n是为了保证下标非负
        if(!col[i] && !dg[u + i] && !udg[n-u+i])//如果这个皇后满足条件，就放进空位上
        {
            g[u][i] = 'Q';
            col[i] = dg[u+i] = udg[n-u+i] =true;//表明这行已被用过
            dfs(u + 1);//递归，去放置下一个位置上的点
            col[i] = dg[u+i] = udg[n-u+i] =false;//恢复现场
            g[u][i] = '.';
        }
    }
}

int main()
{
    cin >> n;
    for(int i = 0;i < n;i++)
        for(int j = 0;j < n;j++)
            g[i][j] = '.';
    dfs(0);
    return 0;
}
```
## 走迷宫-BFS代码模板
```c++
 #include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 110;
typedef pair<int,int> PII;
int n,m;
int g[N][N];//用于保存地图
int d[N][N];//用于存每一个点到起点的距离
PII q[N*N];//用于模拟队列

int bfs()
{
    int hh = 0,tt = 0; //初始化队头队尾
    q[0] = {0,0};
    
    memset(d,-1,sizeof d);//初始化d的所有值为-1,表示都没走过
    d[0][0] = 0;//代表起点已经走过了
    //每一次可以往上下左右四个方向拓展，不用写四个判断，可以用向量来表示上下左右移动
    int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1};//顺序：上右下左
    while(hh <= tt)
    {
        auto t = q[hh ++];//每次取出队头元素
        for(int i = 0;i < 4;i++)
        {
            int x = t.first + dx[i],y = t.second + dy[i];
            //在边界内且能走且是第一次走
            if(x >= 0 && x < n && y >=0 && y < m && g[x][y] ==0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1;//更新距离
                q[++ tt] = {x,y}; 
            }
        }
    }
    return d[n-1][m-1];//输出右下角这个点的距离
}

int main()
{
    cin >> n >> m;
    for(int i = 0;i < n;i++)
        for(int j = 0;j < m;j++)
            cin >> g[i][j];
    cout << bfs() << endl;
    return 0;
}
```

DP问题其实是一类没有环的最短路问题。

## 3.2 树与图的遍历：拓扑排序
### 树与图的存储
树是一种无环连通图。所以只讲图的存储。
图的话分成两种。有向图和无向图。对于无向图，每两个连通的点之间，需要建两条边。
为每个点都写一个单链表。每个点的邻居点次序是没关系的。
邻接矩阵用的比较少，因为空间复杂度比较高。

图的邻接表存储如下：插入的话一般在头节点插入。
![20220425173318](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220425173318.png)

### 树与图的遍历
只需要考虑图是怎么遍历的就行
树和图的深度优先遍历和广度优先遍历，其实是一种特殊的深度优先搜索和广度优先搜索。

凡是涉及到树的遍历，链表的遍历，一般都要用到递归的思想，体现到代码就是dfs。

### 二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）

二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。

四种主要的遍历思想为：

前序遍历：根结点 ---> 左子树 ---> 右子树

中序遍历：左子树---> 根结点 ---> 右子树

后序遍历：左子树 ---> 右子树 ---> 根结点

层次遍历：只需按层次遍历即可

例如，求下面二叉树的各种遍历

![image-20220805122821294](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20220805122821294.png)



前序遍历：1  2  4  5  7  8  3  6 

中序遍历：4  2  7  5  8  1  3  6

后序遍历：4  7  8  5  2  6  3  1

层次遍历：1  2  3  4  5  6  7  8

#### 一、前序遍历

1）根据上文提到的遍历思路：根结点 ---> 左子树 ---> 右子树，很容易写出递归版本：

```c++
public void preOrderTraverse1(TreeNode root) {
		if (root != null) {
			System.out.print(root.val+"  ");
			preOrderTraverse1(root.left);
			preOrderTraverse1(root.right);
		}
	}
```


2）现在讨论非递归的版本：
根据前序遍历的顺序，优先访问根结点，然后在访问左子树和右子树。所以，对于任意结点node，第一部分即直接访问之，之后在判断左子树是否为空，不为空时即重复上面的步骤，直到其为空。若为空，则需要访问右子树。注意，在访问过左孩子之后，需要反过来访问其右孩子，所以，需要栈这种数据结构的支持。对于任意一个结点node，具体步骤如下：

a)访问之，并把结点node入栈，当前结点置为左孩子；

b)判断结点node是否为空，若为空，则取出栈顶结点并出栈，将右孩子置为当前结点；否则重复a)步直到当前结点为空或者栈为空（可以发现栈中的结点就是为了访问右孩子才存储的）

代码如下：

```c++
public void preOrderTraverse2(TreeNode root) {
		LinkedList<TreeNode> stack = new LinkedList<>();
		TreeNode pNode = root;
		while (pNode != null || !stack.isEmpty()) {
			if (pNode != null) {
				System.out.print(pNode.val+"  ");
				stack.push(pNode);
				pNode = pNode.left;
			} else { //pNode == null && !stack.isEmpty()
				TreeNode node = stack.pop();
				pNode = node.right;
			}
		}
	}
```




#### 二、中序遍历

1)根据上文提到的遍历思路：左子树 ---> 根结点 ---> 右子树，很容易写出递归版本：

```c++
public void inOrderTraverse1(TreeNode root) {
		if (root != null) {
			inOrderTraverse1(root.left);
			System.out.print(root.val+"  ");
			inOrderTraverse1(root.right);
		}
	}
```

2）非递归实现，有了上面前序的解释，中序也就比较简单了，相同的道理。只不过访问的顺序移到出栈时。代码如下：
public void inOrderTraverse2(TreeNode root) {
		LinkedList<TreeNode> stack = new LinkedList<>();
		TreeNode pNode = root;
		while (pNode != null || !stack.isEmpty()) {
			if (pNode != null) {
				stack.push(pNode);
				pNode = pNode.left;
			} else { //pNode == null && !stack.isEmpty()
				TreeNode node = stack.pop();
				System.out.print(node.val+"  ");
				pNode = node.right;
			}
		}
	}

#### 三、后序遍历

1）根据上文提到的遍历思路：左子树 ---> 右子树 ---> 根结点，很容易写出递归版本：

public void postOrderTraverse1(TreeNode root) {
		if (root != null) {
			postOrderTraverse1(root.left);
			postOrderTraverse1(root.right);
			System.out.print(root.val+"  ");
		}
	}
2）非递归的代码，暂且不写

#### 四、层次遍历

层次遍历的代码比较简单，只需要一个队列即可，先在队列中加入根结点。之后对于任意一个结点来说，在其出队列的时候，访问之。同时如果左孩子和右孩子有不为空的，入队列。代码如下：

public void levelTraverse(TreeNode root) {
		if (root == null) {
			return;
		}
		LinkedList<TreeNode> queue = new LinkedList<>();
		queue.offer(root);
		while (!queue.isEmpty()) {
			TreeNode node = queue.poll();
			System.out.print(node.val+"  ");
			if (node.left != null) {
				queue.offer(node.left);
			}
			if (node.right != null) {
				queue.offer(node.right);
			}
		}
	}

#### 五、深度优先遍历

其实深度遍历就是上面的前序、中序和后序。但是为了保证与广度优先遍历相照应，也写在这。代码也比较好理解，其实就是前序遍历，代码如下：

```java
public void depthOrderTraverse(TreeNode root) {
		if (root == null) {
			return;
		}
		LinkedList<TreeNode> stack = new LinkedList<>();
		stack.push(root);
		while (!stack.isEmpty()) {
			TreeNode node = stack.pop();
			System.out.print(node.val+"  ");
			if (node.right != null) {
				stack.push(node.right);
			}
			if (node.left != null) {
				stack.push(node.left);
			}
		}
	}
```



## 3.3 最短路



## 3.4 最小生成树



## 3.5 二分图：染色法、匈牙利算法



# 第四讲 数学知识（基本不考）
## 4.1质数

## 4.2约数

## 4.3欧拉函数

## 4.4快速幂

## 4.5扩展欧几里得算法

## 4.6中国剩余定理

## 4.7高斯消元

## 4.8组合计数

## 4.9容斥原理

## 4.10简单博弈论

# 第五讲 动态规划(考)

**1.从常用模型来讲：背包模型**

**2.从类型划分来讲:线性DP，区间DP，计数类DP，数位统计DP等等**

**DP的实现方式：可以用记忆化搜索。**



DP问题没有模板，都是一些循环，它的核心在于状态表示和状态转移。
所谓的状态就是一个未知数。一般来说背包问题的话就是一个二维的vector f[i][j]。根据具体问题思考，需要用几维的状态来表示。
状态计算：就是指如何一步一步地把每一个状态算出来。状态计算就是状态转移方程。

## 5.1 背包问题

### 5.1.1 01背包问题（特点：每件物品最多能用一次)
![20220503111618](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220503111618.png)

动态规划的优化都是对代码做一个等价变形。
**01背包问题**
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
**输入格式**
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。
**输出格式**
输出一个整数，表示最大价值。
**数据范围**
0<N,V≤1000
0<vi,wi≤1000
**输入样例：**
4 5
1 2
2 4
3 4
4 5
**输出样例：**
8
**二维数组形式：**

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n,m;
int v[N],w[N];//v表示体积，w表示价值
int f[N][N];//f表示状态
int main()
{
    cin >> n >> m;//物品个数、背包容量
    for(int i = 1;i <= n;i++)   cin >> v[i] >> w[i];//输入每个物品的体积、价值  注意这里必须从1开始！！！
    for(int i = 1;i <= n;i++)//f[0][0~m]表示考虑0件物品，总体积不超过0~m，故最大价值为0，全局变量以默认初始化，因此从1开始
        for(int j = 0;j <= m;j++)
        {
            f[i][j] = f[i-1][j];//代表不考虑第i件物品，那么价值不变。
            if(j >= v[i])   f[i][j] = max(f[i][j],f[i-1][j-v[i]] + w[i]);//曲线救国，不考虑第i件物品，但是减去体积，加上价值
        }
    cout << f[n][m] << endl;
    return 0;
}
```

状态计算，f[i-1,j-v[i]+w[i]]的例子：今天去饭店吃饭，菜单上有道菜，一共只有j元，已经有一个价值v[i]元的菜是一定要点的了，那么剩下的钱就是j-v[i],剩下可以点的菜也只有i-1道了

优化成一维数组形式：

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n,m;
int v[N],w[N];//v表示体积，w表示价值
int f[N];//一维数组
int main()
{
    cin >> n >> m;//物品个数、背包容量
    for(int i = 1;i <= n;i++)   cin >> v[i] >> w[i];//输入每个物品的体积、价值
    for(int i = 1;i <= n;i++)
        for(int j = m;j >= v[i];j--)//逆序更新 必须要逆序更新，否则不对
            f[j] = max(f[j],f[j-v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```

什么是滚动数组：如果说f(i)只用到了f(i-1)的话，那么可以只开一个两维的数组

滚动数组是DP中的一种编程思想。简单的理解就是让数组滚动起来，每次都使用固定的几个存储空间，来达到压缩，节省存储空间的作用。起到优化空间，主要应用在递推或动态规划中（如01背包问题）。因为DP题目是一个自底向上的扩展过程，我们常常需要用到的是连续的解，前面的解往往可以舍去。所以用滚动数组优化是很有效的。利用滚动数组的话在N很大的情况下可以达到压缩存储的作用。

当然是用时间去换空间的

在斐波那契数列中:

```c++
#include<bits/stdc++.h>
int main()
{
    int i;
    long long d[80];
    d[0]=1;
    d[1]=1;
    for(i=2;i<80;i++)
    {
        d[i]=d[i-1]+d[i-2];
    }
    printf("%lld\n",d[79]);
    return 0;
}
```

上面这个循环d[i]只依赖于前两个数据d[i - 1]和d[i - 2]; 为了节约空间用滚动数组的做法，可以将整个dp数组压缩成dp[3]

```c++
#include<bits/stdc++.h>
int main()
{
    int i;
    long long d[3];
    d[1]=1;
    d[2]=1;
    for(i=2;i<80;i++)
    {
        d[0]=d[1];
        d[1]=d[2];
        d[2]=d[0]+d[1]; 
    }
    printf("%lld\n",d[2]);
    return 0;
}
```

滚动数组在DP中能起很大作用尤其是当原本需要申请得内存大小很大的情况下。



### 5.1.2 完全背包问题（特点：每件物品有无限个）


集合的划分：按照第i个物品选几个来划分。

**题目描述**
有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。
第 i 种物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
**输入格式**
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。
**输出格式**
输出一个整数，表示最大价值。
**数据范围**
0<N,V≤1000
0<vi,wi≤1000
**输入样例：**
4 5
1 2
2 4
3 4
4 5
**输出样例：**
10

朴素写法：

![image-20220723125555438](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20220723125555438.png)

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int n,m;
int f[N][N];
int v[N],w[N];

int main()
{
	cin >> n >> m;
    for(int i = 1;i <= n;i ++) cin >> v[i] >> w[i];
    for(int i = 1;i <= n;i ++) 
        for(int j = 0;j <= m;j++)
            for(int k = 0;k*v[i] <= j;k++)
            	f[i][j] = max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k);
    cout << f[n][m] << endl;
    return 0;
}
```

```c++
//优化成两维的
#include<iostream>
using namespace std;
const int N = 1010;
int n,m;
int f[N][N];
int v[N],w[N];

int main()
{
	cin >> n >> m;
    for(int i = 1;i <= n;i ++) cin >> v[i] >> w[i];
    for(int i = 1;i <= n;i ++) 
        for(int j = 0;j <= m;j++)
        {
            f[i][j] = f[i-1][j];
            if(j >= v[i]) f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//注意和01背包的不同，是从第i层转移过来的，不是第i-1层
        }
    cout << f[n][m] << endl;
    return 0;
}
```

**一维数组优化写法：**就是上面二维数组的等价变形，直接把[i]删掉

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int n,m;
int v[N],w[N];
int f[N];
int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++)   cin >> v[i] >> w[i];
    for(int i = 1;i <= n;i++)
        for(int j = v[i];j <= m;j++)//正序更新，和01背包的最终形态不同
            f[j] = max(f[j],f[j-v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```

01背包是从i-1转移过来的，而完全背包是从第i层转移过来的。

为什么完全背包和01背包只差了这样一个循环顺序呢？一定要想明白这个问题。



### 5.1.3 多重背包问题（特点：每个物品最多有s个)

多重背包问题的时间复杂度是
$$
N*V*log(s)
$$
多重背包问题需要用单调队列来优化。因为它是求滑动窗口的最大值。

**利用二进制优化：**

从1,2,4,8,.....512从这10组当中拼凑出0-1023中任何一个数，不需要枚举从1-1023次。

每一个打包出来的组可以看成是01背包里面的1个物品，因为它只能选一次。那么就是用10个新的物品来表示原来的第i个物品。本来要枚举1024次，现在只用枚举10次，所以就会有一个logN的做法。拆分完之后，对于所有新出来的物品，做一遍01背包即可。

![image-20220724105748839](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20220724105748839.png)

### 5.1.3 多重背包问题（特点：每个物品最多有s个)


**多重背包问题I**
**题目描述**
有 N 种物品和一个容量是 V 的背包。
第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。
b4285f5e6d1c173214320e172d1a00ffafd760a2
**输入格式**
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。
**输出格式**
输出一个整数，表示最大价值。
**数据范围**
0<N,V≤100
0<vi,wi,si≤100
**输入样例：**
4 5
1 2 3
2 4 1
3 4 3
4 5 2
**输出样例：**
10

暴力解法：（就是朴素版本的完全背包问题）

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int n,m;
int v[N],w[N],s[N];
int f[N][N];
int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++)   cin >> v[i] >> w[i] >> s[i];
    for(int i = 1;i <= n;i++)
        for(int j = 0;j <= m;j++)
            for(int k = 0;k <= s[i] && k * v[i] <= j;k++)
                f[i][j] = max(f[i][j],f[i-1][j-v[i]*k] + w[i] * k);
    cout << f[n][m] << endl;
    return 0;
}
```

**多重背包问题 II**
**题目描述**
有 N 种物品和一个容量是 V 的背包。
第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。
**输入格式**
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。
输出格式
输出一个整数，表示最大价值。
**数据范围**
0 < N ≤ 1000
0 < V ≤ 2000
0 < vi,wi,si ≤ 2000
提示：
本题考查多重背包的二进制优化方法。
**输入样例：**
4 5
1 2 3
2 4 1
3 4 3
4 5 2
**输出样例：**
10

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 12010,M = 2010;//一共有1000个物品，每个物品最多拆分成log2000个物品，故是N的由来
int n,m;
int v[N],w[N];
int f[M];
int main()
{
    cin >> n >> m;
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        int a,b,s;
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s)
        {
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if(s > 0)
        {
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    n = cnt;//每个数选与不选都能拼凑出任意的数字，这就是2进制的妙用
    for (int i = 1; i <= n; i++)//二进制方式转换成01背包问题
        for(int j = m;j >= v[i];j--)
            f[j] = max(f[j],f[j-v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```

记住：

如果转移时，我们用的是上一层的状态的话，就要从大到小来枚举体积。

如果我们用的是本层状态的话，就要从小到大来枚举体积。

原因：如果用的是上一层的状态，从大到小来枚举体积的话，可以保证算这个体积的时候，所用到的体积还没有被计算过。




### 5.1.4 分组背包问题(特点：物品有N组，每组物品有若干个，一组里面只能选一个物品)

**题目描述**
有 N 组物品和一个容量是 V 的背包。
每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
输出最大价值。


**输入格式**
第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。
接下来有 N 组数据：
每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；
**输出格式**
输出一个整数，表示最大价值。
**数据范围**
0 < N,V ≤ 100
0 < Si ≤ 100
0 < vij,wij ≤ 100
**输入样例：**
3 5
2
1 2
2 4
1
3 4
1
4 5
**输出样例：**
8

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int n,m;
int v[N][N],w[N][N],s[N];
int f[N];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> s[i];
        for(int j = 0;j < s[i];j++)
            cin >> v[i][j] >> w[i][j];
    }
    for(int i = 1; i <= n;i++)
        for(int j = m;j >= 0;j--)//需要从上一状态转移，故从大到小，不太好确定最小值就用了大于等于0，毕竟下面有个if支撑
            for(int k = 0;k < s[i];k++)
                    if(v[i][k] <= j)    f[j] = max(f[j],f[j - v[i][k]] + w[i][k]);
    cout << f[m] << endl;
    return 0;
}
```



## 5.2 线性DP

**题目一：数字三角形**
题目描述
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```c++
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

**输入格式**
第一行包含整数 n，表示数字三角形的层数。
接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。
**输出格式**
输出一个整数，表示最大的路径数字和。
**数据范围**
1 ≤ n ≤ 500,
−10000 ≤ 三角形中的整数 ≤ 10000
**输入样例：**
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
**输出样例：**
30

**方法一(处理边界的正向DP)：**

自己的代码：

```c++
#include <iostream>
using namespace std;

const int N = 510,INF = 1e9;
int n;
int a[N][N];
int f[N][N];

int main()
{
    cin >> n;
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= i;j++)
                cin >> a[i][j];
    //这里初始化要注意，需要多初始化一部分，因为计算时会将右上角也计算进去
    for(int i = 0;i <= n;i++)
        for(int j = 0;j <= i+1;j++)
            f[i][j] = -INF;

    f[1][1] = a[1][1];
    for(int i = 2;i <= n;i++)
        for(int j = 1;j <= i;j++)
            f[i][j] = max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);
    int res = -INF;
    for(int i = 1;i <= n;i++)  res = max(res,f[n][i]);
    cout << res << endl;
    return 0;
}
```





![20220731112535](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/20220731112535.png)
f[i][j]表示从起点走到[i][j]这个点的最大值
所以状态计算为`max(f[i-1,j-1]+a[i,j],f[i-1,j]+a[i,j])`
涉及到i-1这种下标，i应该从1计算比较好。
动态规划的时间复杂度一般是 状态数量x状态转移的计算量



**题目2：最长上升子序列**
![20220731160830](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/20220731160830.png)
最长上升子序列1:
给定一个长度为N的数列(w[N])，求数值严格单调递增的子序列的长度最长是多少。

样例:
**输入格式**
第一行包含整数N。
第二行包含N个整数，表示完整序列。

**输出格式**
输出一个整数，表示最大长度。

**数据范围**
1 ≤ N ≤ 1000，
−1e9 ≤ 数列中的数 ≤ 1e9

**输入样例：**
7
3 1 2 1 8 5 6 
**输出样例：**
4
**算法1:**
(动态规划) O(n2)
状态表示：**f[i]表示从第一个数字开始算，以w[i]结尾的最大的上升序列的长度**。(以w[i]结尾的所有上升序列中属性为最大值的那一个)

状态计算（集合划分）：j∈(0,1,2,..,i-1), 在w[i] > w[j]时，
f[i] = max(f[i], f[j] + 1)。
有一个边界，若前面没有比i小的，f[i]为1（自己为结尾）。

最后在找f[i]的最大值。

时间复杂度
`O(n^2) `状态数(n) * 转移数(n)

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n;
int w[N], f[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> w[i];

    int mx = 1;    // 找出所计算的f[i]之中的最大值，边算边找
    for (int i = 0; i < n; i++)
    {
        f[i] = 1;    // 设f[i]默认为1，找不到前面数字小于自己的时候就为1
        for (int j = 0; j < i; j++) 
        {
            if (w[i] > w[j]) f[i] = max(f[i], f[j] + 1);    // 前一个小于自己的数结尾的最大上升子序列加上自己，即+1
        }
        mx = max(mx, f[i]);//找出结果，所有f[i]中最大的
    }

    cout << mx << endl;
    return 0;

}
```



**最长上升子序列2:**
给定一个长度为N的数列(w[N])，求数值严格单调递增的子序列的长度最长是多少。

样例:
**输入格式**
第一行包含整数N。
第二行包含N个整数，表示完整序列。

**输出格式**
输出一个整数，表示最大长度。

**数据范围**
1 ≤ N ≤ 100000，
−1e9 ≤ 数列中的数 ≤ 1e9

**输入样例：**
7
3 1 2 1 8 5 6 
**输出样例：**
4

遍历a数组里面的数，然后在q（这个数组的长度就是答案）这个数组里面查找是否存在一个大于且最靠近他的数，(即二分和lower_bound作用)
若果不存在话，说明这个数是在q所有的数中是最大的
（这时下标也已经扫描到q数组的最右边，r这个下标已经定位到q的最右边，将其+1，更新q长度（即：更新答案）和新元素的值），
若存在（即：该点的值不是上升地），r+1也不会增加q的长度（因为不是上升的情况，所以这里答案不会更新），说明该点最长子序列一定是前面其中的某个答案，只需要将里面地最靠近的那个元素进行更新即可



算法1
思路：首先数组a中存输入的数（原本的数），开辟一个数组f用来存结果，最终数组f的长度就是最终的答案；假如数组f现在存了数，当到了数组a的第i个位置时，首先判断a[i] > f[cnt] ？ 若是大于则直接将这个数添加到数组f中，即f[++cnt] = a[i];这个操作是显然的。
当a[i] <= f[cnt] 的时,我们就用a[i]去替代数组f中的第一个大于等于a[i]的数，因为在整个过程中我们维护的数组f 是一个递增的数组，所以我们可以用二分查找在 logn 的时间复杂的的情况下直接找到对应的位置，然后替换，即f[l] = a[i]。

我们用a[i]去替代f[i]的含义是：以a[i]为最后一个数的严格单调递增序列,这个序列中数的个数为l个。

这样当我们遍历完整个数组a后就可以得到最终的结果。

时间复杂度分析：O(nlogn)
C++ 代码



```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int N = 1e6 + 10;

int n, cnt;
int a[N], dp[N];
vector<int> q;//用q数组表示q[i]为长度为i时结尾最小的数字
int main()
{
   cin>>n;
   for(int i = 0; i < n; i ++ ) cin >> a[i];
   q.push_back(a[0]);
   for(int i = 1; i < n; i ++ )
    {
    //二分查找小于a[i]的最大数字
    int l = 0, r = q.size()-1;

    if(a[i]>q[r]) {
        q.push_back(a[i]);
        continue;
    }
    if(a[i]<q[0]) {
        q[0]=a[i];
        continue;
    }
    while(l < r)
    {
        int mid = l + r + 1 >> 1;
        if(a[i] > q[mid]) l = mid;
        else r = mid - 1;
    }
    q[r+1]=a[i];
    }
     cout << q.size() << endl;

}
```

时间复杂度 遍历数组O(n) 二分查找O(logn） 故为O(nlogn)

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+10;
int a[N],n;

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;++i)scanf("%d",&a[i]);

    vector<int> f;
    
    //因为f是一个递增的序列，所以最大值要最后push进去
    for(int i=0;i<n;++i){
        auto pos=lower_bound(f.begin(),f.end(),a[i]);//从f中找到大于等于a[i]的第一个数，没找到即a[i]>f
        if(pos!=f.end())*pos=a[i];//找到了，我们就用a[i]去替代数组f中的第一个大于等于a[i]的数，因为pos是迭代器，所以这里有替代数组元素的作用。
        else f.push_back(a[i]);//没找到，那么将a[i]加入到f中
    }
    cout<<f.size()<<endl;
    return 0;
}
```



**题目3：最长公共子序列：**

这题的状态分成两半考虑比较方便，按两个序列末尾的字符是不是相等来区分。

![image-20220801163613666](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20220801163613666.png)

如果两个字符相等，就可以直接转移到`f[i-1][j-1]`，不相等的话，两个字符一定有一个可以抛弃，可以对`f[i-1][j],f[i][j-1]`两种状态取max来转移。

![image-20220801162520541](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20220801162520541.png)

```c++
#include <iostream>
using namespace std;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];
int main() {
  cin >> n >> m >> a + 1 >> b + 1;//处理输入，等同于scanf("%s",a+1)  已经把字符数组存好了
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (a[i] == b[j]) {
        f[i][j] = f[i - 1][j - 1] + 1;
      } else {
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);
      }
    }
  }
  cout << f[n][m] << '\n';
  return 0;
}
```

**题目4：编辑距离：**



## 5.3 区间DP



所谓区间DP问题，是在定义状态的时候，定义了一个区间。即状态表示：用一个区间来表示

**题目1：石子合并：**

设有 N 堆石子排成一排，其编号为 1，2，3，…，N。

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 44 堆石子分别为 `1 3 5 2`， 我们可以先合并 1、2 堆，代价为 44，得到 `4 5 2`， 又合并 1，2 堆，代价为 9，得到 `9 2` ，再合并得到 11，总代价为 4+9+11=24；

如果第二步是先合并 2，3堆，则代价为 7，得到 `4 7`，最后一次合并代价为 11，总代价为 4+7+11=22。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

**输入格式**

第一行一个数 N 表示石子的堆数 N。

第二行 N 个数，表示每堆石子的质量(均不超过 1000)。

**输出格式**

输出一个整数，表示最小代价。

**数据范围**

1≤N≤300

**输入样例**：

```
4
1 3 5 2
```

**输出样例**：

```
22
```

==状态表示：所有将第i堆石子到第j堆石子合并成一堆石子的合并方式。显然求完之后，f[1,n]就是答案。==

属性：所有合并方式代价的最小值。

![image-20220814092741944](https://raw.githubusercontent.com/Howardcl/MyImage/main/image-20220814092741944.png)

以最后一次分界线的位置来分类。比如左边一个，右边k-1个;左边两个，右边k-2个等等；

合并的最小代价=左边的最小代价+右边的最小代价+最后一次合并的代价。

因为最终的合并肯定是2堆合并成1堆。所以可以先将最后一步去掉，再加上最后一步的代价。

前缀和表示代价。最后一次合并的代价就是从i到j的和，所以是s[j]-s[i-1]

![image-20220814101456519](https://raw.githubusercontent.com/Howardcl/MyImage/main/image-20220814101456519.png)

**区间 DP 常用模版**
所有的区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 len = 1 时用来初始化，枚举从 len = 2 开始；第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）

```c++
#include <iostream>

using namespace std;

const int N = 310;
int n;
int s[N];
int f[N][N];

int main()
{
    cin >> n;

    for(int i = 1;i <= n;i++) 
    {
        cin >> s[i];
        s[i] += s[i-1];//前缀和
    }
    
    for(int len = 2; len <= n;len++)// 区间长度
        for(int l = 1; l + len - 1 <= n;l++)// 枚举起点
        {
            int r = l + len - 1;// 区间终点
            f[l][r] = 1e8;
            for(int k = l; k < r;k++)// 枚举分割点，构造状态转移方程
            {
                f[l][r] = min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);
            }
        }
    cout << f[1][n] << endl;//输出结果
    return 0;
}
```

时间复杂度O($n^3$)

因为状态表示是O($n^2$),在每个状态中的计算是O(n)

区间DP问题套路，先枚举区间长度，再枚举区间起点，然后进行状态计算。

## 5.4 计数类DP

整数划分：


一个正整数 n 可以表示成若干个正整数之和，形如：n=n1+n2+…+nk，其中 n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数 n 的一种划分。

现在给定一个正整数 n，请你求出 n共有多少种不同的划分方法。

**输入格式**

共一行，包含一个整数 n。

**输出格式**

共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 109+7 取模。

**数据范围**

1≤n≤1000

**输入样例**:

```
5
```

**输出样例**：

```
7
```





## 5.5 数位统计DP

**题目：**

给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼90∼9 的出现次数。

例如，a=1024，b=1032，则 a 和 b 之间共有 9个数如下：

```
1024 1025 1026 1027 1028 1029 1030 1031 1032
```

其中 `0` 出现 10次，`1` 出现 10 次，`2` 出现 7 次，`3` 出现 3次等等…

**输入格式**

输入包含多组测试数据。

每组测试数据占一行，包含两个整数 a和 b。

当读入一行为 `0 0`  时，表示输入终止，且该行不作处理。

**输出格式**

每组数据输出一个结果，每个结果占一行。

每个结果包含十个用空格隔开的数字，第一个数字表示 `0` 出现的次数，第二个数字表示 `1` 出现的次数，以此类推。

**数据范围**

0<a,b<100000000

**输入样例**：

```
1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
```

**输出样例**：

```
1 2 1 1 1 1 1 1 1 1
85 185 185 185 190 96 96 96 95 93
40 40 40 93 136 82 40 40 40 40
115 666 215 215 214 205 205 154 105 106
16 113 19 20 114 20 20 19 19 16
107 105 100 101 101 197 200 200 200 200
413 1133 503 503 503 502 502 417 402 412
196 512 186 104 87 93 97 97 142 196
398 1375 398 398 405 499 499 495 488 471
294 1256 296 296 296 296 287 286 286 247
```

分析思路：

![image-20220814124451727](https://raw.githubusercontent.com/Howardcl/MyImage/main/image-20220814124451727.png)

分别求1在每1位上出现的次数。枚举所有情况。分析过程如下图：

![image-20220814134920258](https://raw.githubusercontent.com/Howardcl/MyImage/main/image-20220814134920258.png)

注意，统计“0”的时候，要注意，数位统计 DP 里“前导 0” 的说法可能有些误导，实际上是这样的意思：

假如第 k 位为 00，并且它的前面是全 0，那么就相当于第 k 位并不存在，也就不能算是一个方案数。

例如，要在 abcdefg 中找第 4位为 00 的数。
假如 abc 为 000，dd 也为 0，那么就会有 0000efg。但是，0000efg 实际上就是 efg，它并不存在第四位，因此也就不能算是第 4 位为 0 的数。

## 



## 5.6 状态压缩DP

状压DP之蒙德里安的梦想：
求方案数，首先因为他的摆法无非两种，而且要摆满，那其实就和染色问题（黑白两色）一样，对于某一种方案，一旦确定了横着放的情况，那么剩下的竖着放的方案也就唯一确定了。值得注意的是我们在枚举横着放的情况的时候，要想办法保证剩下的空间用来竖着摆放的合法性。



![image-20220814142432607](https://raw.githubusercontent.com/Howardcl/MyImage/main/image-20220814142432607.png)

**输入格式**

输入包含多组测试用例。

每组测试用例占一行，包含两个整数 N和 M。

当输入用例 N=0，M=0时，表示输入终止，且该用例无需处理。

**输出格式**

每个测试用例输出一个结果，每个结果占一行。

**数据范围**

1≤N,M≤11

**输入样例**：

```
1 2
1 3
1 4
2 2
2 3
2 4
2 11
4 11
0 0
```

**输出样例**：

```
1
0
1
2
3
5
144
51205
```

当横向小方格放完之后，纵向小方格就只有一种放法了。例如下图，

就是，我们的状态虽然是一个整数，但是我们却要把他们看成是一个二进制数。二进制数里的每一位是0是1，表示不同的状态。

![image-20220814142840594](https://raw.githubusercontent.com/Howardcl/MyImage/main/image-20220814142840594.png)







**题目：最短Hamilton路径**

给定一张 n个点的带权无向图，点从 0∼n−1标号，求起点 0 到终点 n−1的最短 Hamilton 路径。

Hamilton 路径的定义是从0到 n−1不重不漏地经过每个点恰好一次。

**输入格式**

第一行输入整数 n。

接下来 n 行每行 n 个整数，其中第 i 行第 j个整数表示点 i到 j的距离（记为a[i,j]）。

对于任意的 x,y,z，数据保证 $a[x,x]=0，a[x,y]=a[y,x]$并且 $a[x,y]+a[y,z]≥a[x,z]$。

**输出格式**

输出一个整数，表示最短 Hamilton 路径的长度。

**数据范围**

1≤n≤20
0≤a[i,j]≤$10^7$

**输入样例**：

```
5
0 2 4 5 1
2 0 6 5 3
4 6 0 8 3
5 5 8 0 5
1 3 3 5 0
```

**输出样例**：

```
18
```

## 5.7 树形DP

题目：

Ural 大学有 N 名职员，编号为 1∼N。

他们的关系就像一棵以校长为根的树，父节点就是子节点的直接上司。

每个职员有一个快乐指数，用整数 Hi 给出，其中 1≤i≤N。

现在要召开一场周年庆宴会，不过，没有职员愿意和直接上司一起参会。

在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。

**输入格式**

第一行一个整数 N。

接下来 N行，第 i 行表示 i 号职员的快乐指数 Hi。

接下来 N−1 行，每行输入一对整数 L,K，表示 K是 L的直接上司。

**输出格式**

输出最大的快乐指数。

**数据范围**

1≤N≤6000
−128≤Hi≤127

**输入样例**：

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

**输出样例**：

```
5
```





## 5.8 记忆化搜索

==DP问题的递归写法：记忆化搜索。==

**题目：滑雪**

给定一个 R行 C 列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 i行第 j 列的点表示滑雪场的第 i 行第 j列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。

在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 25个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

**输入格式**

第一行包含两个整数 R 和 C。

接下来 R 行，每行包含 C个整数，表示完整的二维矩阵。

**输出格式**

输出一个整数，表示可完成的最长滑雪长度。

**数据范围**

1≤R,C≤300
0≤矩阵中整数≤10000

**输入样例**：

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

**输出样例**：

```
25
```



**最长回文子序列：**

```c++
#include <iostream>
#include <vector>
using namespace std;

int longestPalindromeSubseq(string s) {
    int n = s.length();
    vector<vector<int>> dp(n,vector<int>(n,0));
    for(int i=0; i<n; i++)
        dp[i][i] = 1;
    for(int i=n-2; i>=0; i--){
        for(int j=i+1; j<n; j++){
            if(s[i]==s[j])
                dp[i][j] = dp[i+1][j-1] + 2;
            else
                dp[i][j] = max(dp[i+1][j],dp[i][j-1]);   
        }
    }
    return dp[0][n-1];
}

int main()
{
    string str;
    cin >> str;
    cout << longestPalindromeSubseq(str);
 
	return 0;
}
```



# 第六讲 贪心

## 6.1 区间问题

**AcWing 905. 区间选点**



**AcWing 908. 最大不相交区间数量**



**AcWing 906. 区间分组**



**AcWing 907. 区间覆盖**



## 6.2 Huffman树

**AcWing 148. 合并果子**

## 6.3 排序不等式

**AcWing 913. 排队打水**

## 6.4 绝对值不等式

**AcWing 104. 货仓选址**

## 6.5 推公式

**AcWing 125. 耍杂技的牛**



# 第七讲 时间复杂度分析
只有当输入超过100万时，才会必须要用scanf，否则用cin没什么区别。

new运算符返回的是新开辟类型的地址。故赋值号前都是类型的指针。new是在堆区开辟的。

## 时间复杂度
  时间复杂度往往只是定性描述，即不需要算出来具体数值。仅需要有大体的估算结果（有点像高数中的极限，仅考虑n趋近于正无穷时的情况）。下面给出几种常见时间复杂度的代码。
  ```c++
  #include<iostream>
using namespace std;
int n,ans;
int main(){
	cin>>n;
	//O(1)和数据输入规模无关
	for(int i=0;i<9;++i)
		ans+=n;
	
	//O(logn)一般默认底数是2（就算不是也可以用指数换底公式换成2）
	for(int i=n;i;i/=2)
		ans+=n;
	
	//O(√n)
	for(int i=1;i*i<n;++i)
		ans+=n;
	
	//O(n)线性时间复杂度
	for(int i=0;i<n;++i)
		ans+=n;
	
	//O(n^2)
	for(int i=1;i<n;++i)
		for(int j=i+1;j<n;++j)
			ans+=n;
	
	return 0; 
}
  ```
此外，还有O(n!)（阶乘级）、O(C^n)（指数级）等时间复杂度。很显然，在大规模数据下这种复杂度的算法是不可行的，因此应注意规避此类算法。
 由以上，计算出的时间复杂度为10^8级别以下，则在可接受范围之内。


## 空间复杂度
可用sizeof(类型名或该类型的变量名)查看占用字节数。常用类型包括：

        int：32位二进制，2^31-1=2147483647（约10^9）可用于判断是否需要使用更大类型（如long long类型）的变量存储数据。
    
        long long：64位二进制，2^63-1（约10^18） 
    
        char：8位二进制
    
        bool：8位二进制，但仅有0和1 
    
        double：64位二进制，需要注意的是，当将一个十进制小数转化为二进制小数时，可能会转化为一个无限循环小数。如：0.5、 0.25、 0.125转化为二进制分别为0.1、 0.01、 0.001，但十进制的0.3很明显不能由二进制拼出。可运行如下代码进行测试：
```c++
#include<iostream>
using namespace std;
double n,ans;
int main(){
    
    cout<<(0.1+0.2==0.3);//结果为0，说明等式不成立
    //因此若想判断两小数运算相等，最好用 0.1+0.2-0.3<=1e-7 的方式
    
    return 0;
}
```

1. **内联函数**

在C++中我们通常定义以下函数来求两个整数的最大值：

代码如下:

``` c++
int max(int a, int b)
{
 return a > b ? a : b;
}
```

为这么一个小的操作定义一个函数的好处有：

① 阅读和理解函数 max 的调用，要比读一条等价的条件表达式并解释它的含义要容易得多

② 如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多

③ 使用函数可以确保统一的行为，每个[测试](http://lib.csdn.net/base/softwaretest)都保证以相同的方式实现

④ 函数可以重用，不必为其他应用程序重写代码

虽然有这么多好处，但是写成函数有一个潜在的缺点：**==调用函数比求解等价表达式要慢得多。==**在大多数的机器上，调用函数都要做很多工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行

**C++中支持内联函数，其目的是为了提高函数的执行效率**，用关键字 inline 放在函数定义(注意是定义而非声明，下文继续讲到)的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开，假设我们将 max 定义为内联函数：

```c++
inline int max(int a, int b)
{
 return a > b ? a : b;
}
```

则调用： `cout<<max(a, b)<<endl;`
在编译时展开为： `cout<<(a > b ? a : b)<<endl;`

从而消除了把 max写成函数的额外执行开销。

2. **内联函数和宏**

无论是《Effective C++》中的 “Prefer consts，enums，and inlines to #defines” 条款，还是《高质量程序设计指南——C++/[C语言](http://lib.csdn.net/base/c)》中的“用函数内联取代宏”，宏在C++中基本是被废了，在书《高质量程序设计指南——C++/C语言》中这样解释到：

3. **将内联函数放入头文件**

关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。

如下风格的函数 Foo 不能成为内联函数：

代码如下:

```c++
inline void Foo(int x, int y);  // inline 仅与函数声明放在一起  
void Foo(int x, int y)
{
 ...
} 
```

而如下风格的函数 Foo 则成为内联函数：

代码如下:

```c++
void Foo(int x, int y);  
inline void Foo(int x, int y)  // inline 与函数定义体放在一起
{
 ...
} 
```

所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：**声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。**

**定义在类声明之中的成员函数将自动地成为内联函数**，例如：

代码如下:

```c++
class A
{ 
public:
 void Foo(int x, int y) { ... }  // 自动地成为内联函数 
} 
```

但是编译器是否将它真正内联则要看 Foo函数如何定义

**内联函数应该在头文件中定义，**这一点不同于其他函数。编译器在调用内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。

当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。


2.**const的作用**

（1）const用于定义常量：const定义的常量编译器可以对其进行数据静态类型安全检查。

（2）const修饰函数形式参数：当输入参数为用户自定义类型和抽象数据类型时，应该将值传递改为const &传递，可以提高效率。比较下面两段代码：
```c++
void fun(A a);
void fun(A const &a);
```
第一个函数效率低。函数体内产生A类型的临时对象用于复制参数a，临时对象的构造、复制、析构过程都将消耗时间。而第二个函数提高了效率。用引用传递不需要产生临时对象，节省了临时对象的构造、复制、析构过程消耗的时间。但是只有引用有可能会改变a，所以加const。

（3）const修饰函数的返回值：如给指针传递的函数返回值加const，则返回值不能被直接修改，且该返回值只能被赋值给加const修饰的同类型的指针，例如：
```c++
const char *GetChar(void){};
char *ch = GetChar();     //error
const char *ch = GetChar();   //correct
```
（4）const修饰类的成员函数（函数定义体）：任何不会修改数据成员的函数都应用const修饰，这样，当不小心修改了数据成员或调用了非const成员函数时，编译器都会报错。const修饰类的成员函数形式为：
```c++
int GetCount(void) const;//注意const放的位置（放在最后）
```
（5）
当const修饰函数形参时，顶层const会被忽略，即：
```c++
void fcn(const int i){/*fcn能够读取i，但不能修改i*/}
void fcn(int i){/*.....*/}//错误：重复定义了fcn
```

要尽量使用常量引用

（6）数组形参和const
# 第一讲 基础算法

## 1.1 排序(总结一下：时间复杂度 稳定性 排序思想)

排序主要讲==快速排序==和==归并排序==。主要理解并背过代码模板，要达到能到快速把代码模板默写出来。这个工作很重要。然后用题目来检验模板是否记忆的很好，刷题大概可以重复3-5次。

### 1.1.1 快速排序

主要思想是基于分治。算法流程如下：

1. **确定分界点**
2. **调整区间**
3. **递归处理左右两段**

其中调整区间所用的思想是双指针：两端指针分别向中间移动，直到不满足``q[i]<x``,``q[j]>x``时停止移动，当双指针都停止移动时，交换此时它们所指向的值``swap``，然后继续移动，直到双指针相遇``i=j``。



![image-20211116093224801](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211116093224801.png)

**==快排代码模板：==**

```c++
//注意边界问题，分界点如果选取q[l]或q[r]，都有可能产生死循环，如果选中间则不会
#include <iostream>

using namespace std;

const int N = 100010;

int q[N];

void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;//递归终止条件

    int i = l - 1, j = r + 1, x = q[l + r >> 1];//确定分界点 分界点为数组中具体的值
    while (i < j)//调整区间
    {
        do i ++ ; while (q[i] < x);//如果跳出循环，说明q[i]>=x
        do j -- ; while (q[j] > x);//如果跳出循环，说明q[j]<=x
        if (i < j) swap(q[i], q[j]);
    }

    quick_sort(q, l, j);//递归处理左右两段
    quick_sort(q, j + 1, r);
}

int main()
{
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    quick_sort(q, 0, n - 1);

    for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);

    return 0;
}

```

### 1.1.2 归并排序

归并排序的思想也是分治，与快排不同之处是，快排选的是某个点的值，而归并是以数组中间点的位置来分。

算法流程如下：

**1.确定分界点``mid=(l+r)/2``，数组分为``left``,``right``；**

**2.对左右两边都进行递归排序,得到两个有序数组；**

**3.对两个有序数组进行合并，思路是双指针算法，用两个指针分别指向两个有序数组的最小值，然后对这两个最小值进行比较，最小的值放在``res``数组中，直到有一个指针到达尽头，另一个数组剩下的部分添加到队尾即可。**

![image-20211116111226788](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211116111226788.png)

![image-20211116111604958](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211116111604958.png)

时间复杂度：每次遍历长度为n，通过递归一共有``log_n``层（因为要划分到长度为1的有序数组），所以总的时间复杂度是``O(nlogn)``。

![image-20211116112734735](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211116112734735.png)

**==归并排序代码模板：==**

```c++
#include<iostream>

using namespace std;

const int N = 100010;
int n;
int q[N],temp[N];

void merge_sort(int q[],int l,int r)
{
    if(l >= r) return; //递归终止条件
    int mid = l+r >> 1; //分界点
    merge_sort(q,l,mid),merge_sort(q,mid + 1,r); //递归左右数组
    
    int k = 0,i = l,j = mid + 1;  //合并两个有序数组到temp数组
    while(i <= mid && j <= r)
    {
        if(q[i] <= q[j]) temp[k++] = q[i++];
        else temp[k++] = q[j++];
    }
    while(i <= mid) temp[k++] = q[i++];//两个数组中还剩下的部分，加到temp数组后面
    while(j <= r) temp[k++] = q[j++];
    
    for(int i = l,j = 0;i <= r;i++,j++) q[i] = temp[j]; //从temp数组复制到原数组
}

int main()
{
    scanf("%d",&n);
    for(int i = 0;i < n;i++) scanf("%d",&q[i]);
    
    merge_sort(q,0,n-1);
    
    for(int i = 0;i < n;i++) printf("%d ",q[i]);
    return 0;
}
```

## 1.2 二分(考)

简单定义：在一个单调有序的集合中查找元素，每次将集合分为左右两部分，判断解在哪个部分中并调整集合上下界，重复直到找到目标元素。

时间复杂度：O (logn)，优于直接顺序查找O(n)

主要讲整数二分和浮点数二分。

### 1.2.1 整数二分

二分的本质：并不是单调性，如果有单调性就一定可以二分，可以二分的题目不一定非得有单调性，如果没有单调性，也有可能可以二分。**二分的本质是边界**，给定我们一个区间，**在这个区间上定义某种性质，这种性质在右半边满足，在左半边不满足**，如果可以找到这样一种性质，将区间一分为二的话，那二分就可以寻找这个性质的边界。（例如下图的两点）

![image-20211118194721560](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211118194721560.png)

**==算法思路==**：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。当想要的target在左半区间时，就要更新右边界，即``r=mid``,所以相应地``l =mid + 1``,当target在右半区间时，需要更新左边界,即``l = mid ``,相应的``r = mid - 1``.

==二分模板==一共有两个，分别适用于不同情况。

**版本1**
当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。

```c++
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

**版本2**

当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，==此时为了防止死循环，计算mid时需要加1。==

```c++
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```



### 1.2.2 浮点数二分

浮点数二分就没有边界问题了，不用考虑+1的问题。思路：直接二分，选取想要的区间，更新边界值等于mid即可。

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```



## 1.3 高精度

一般考四种

1.两个比较大的整数相加，``A+B``，位数在$10^6$以内，即整数的长度在1000000以内。

2.两个比较大的整数相减``A-B``

3.一个大整数乘小整数`A*b`

4.``A/b``,求商和余

### 1.3.1 高精度加法

**算法流程**

1.首先是大整数的存储，==用int变量是存不下来的，其实是把大整数的每一位存到数组里面去==。存的时候就有问题了，是高位在前还是低位在前呢？

一般把个位（低位）放在数组首位，因为进位的时候，往数组尾端插入是最容易的。即==个位放首位，高位放队尾。==

2.然后是用数组模拟加法。如果A还有，则加A，B还有，则加B

![image-20211119192201333](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211119192201333.png)

**高精度加法-算法模板**

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )//从个位开始加
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;//进位
    }

    if (t) C.push_back(t);
    return C;
}
```

### 1.3.2 高精度减法

![image-20211119194243148](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211119194243148.png)

**高精度减法-算法模板**

```c++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )//从个位开始减
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);//+10 是因为t可能减不到，是负的
        if (t < 0) t = 1;//意味着借位了，则计算高位的A[i]是要减去1
        else t = 0;//否则没有借位，正常减
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();//去掉前导0（即去掉数组高位-后面的0）
    return C;
}
```

### 1.3.3 高精度乘法

**高精度乘低精度 —— 模板**

```C++
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;//进位
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);//取出个位
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```

### 1.3.4 高精度除法

前面的加减乘都是从低位开始算，但除法是从高位开始算的。除法得到商和余

```c++
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];//中间量的余数，用于下一步的除法
        C.push_back(r / b);//把商加进去
        r %= b;//每一步剩下的余数
    }
    reverse(C.begin(), C.end());//因为前面的除法步骤是把高位数放在数组的低位的，这与我们要求数组尾放高位是相反的，故需要逆转
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

## 1.4 前缀和差分

​	前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。

**前缀和思维导图**

![image-20211128150825268](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128150825268.png)

### 1.4.1 一维前缀和

前缀和数组：$S_i=a_1+a_2+...+a_i$

==作用：快速求出原数组中一段数的和。可以用一次运算算出任意一段数的和。==

![image-20211122111917173](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211122111917173.png)

如何算$S_i$，$S_i=S_{i-1}+a_i$。

**一维前缀和 —— 模板**

```c++
S[i] = a[1] + a[2] + ... a[i]
S[i] = S[i-1]+a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

### 1.4.2 二维前缀和

$S_{ij}$表示左上角所有元素的和。

![image-20211128142140909](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128142140909.png)

```C++
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

### 1.4.3 一维差分

**差分思维导图：**

![image-20211128150932746](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128150932746.png)

类似于数学中的求导和积分，**差分可以看成前缀和的逆运算**。

差分数组：首先给定一个原数组``a：a[1], a[2], a[3],,,,,, a[n]``;

然后我们构造一个数组``b：b[1],b[2],b[3],,,,,, b[i]``;使得 ``a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]``

也就是说，**a数组是b数组的前缀和数组**，**反过来我们把b数组叫做a数组的差分数组**。换句话说，每一个a[i]都是b数组中从头开始的一段区间和。考虑如何构造差分b数组？最为直接的方法:

![image-20211128145716120](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128145716120.png)

我们只要有`b`数组，通过前缀和运算，就可以在`O(n)` 的时间内得到`a`数组 。

![image-20220320180406118](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20220320180406118.png)

**代码模板**

```c++
#include<iostream>

using namespace std;

const int N = 1e6 + 10;

int n,m;
int a[N],b[N];

int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++) 
    {
        scanf("%d",&a[i]);
        b[i] = a[i] - a[i-1];//构建差分数组
    } 

    int l,r,c;
    while(m--)
    {
        cin >> l >> r >> c;
        b[l] += c;  //将序列中[l, r]之间的每个数都加上c
        b[r+1] -= c;
    }
    for(int i = 1;i <= n;i++)
    {
        a[i] = b[i] + a[i-1]; //前缀和运算,根据差分数组更新原数组
        printf("%d ",a[i]);
    }
    return 0;
}
```



### 1.4.4 二维差分		

![	](https://raw.githubusercontent.com/Howardcl/MyImage/main/img/image-20211128154758230.png)

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int a[N][N],b[N][N];

void insert(int x1,int y1,int x2,int y2,int c)
{
    b[x1][y1] += c;
    b[x1][y2+1] -= c;
    b[x2+1][y1] -= c;
    b[x2+1][y2+1] += c;
}
int main()
{
    int n,m,q;
    cin >> n >> m >> q;
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= m;j++)
        {
            scanf("%d",&a[i][j]);
            insert(i,j,i,j,a[i][j]);//构建差分数组
        }
    while(q--)
    {
        int x1,y1,x2,y2,c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1,y1,x2,y2,c);
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            a[i][j] = b[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];//根据差分数组更新原数组
        }
    }
    for(int i = 1;i <= n;i++)
    {   
        for(int j = 1;j <= m;j++)
        {   
            printf("%d ",a[i][j]);
        }
        cout << endl;
    }
    return 0;
}
```



## 1.5 双指针算法(考)
**双指针的核心思想**：
先想一下暴力做法是什么，在挖掘一些性质，使得问题的时间复杂度降低。
**双指针模板**
```c++
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```
###最长连续不重复子序列
####题目描述
给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
**输入格式**
第一行包含整数 n。
第二行包含 n 个整数（均在 0∼105 范围内），表示整数序列。

**输出格式**
共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。
数据范围
```1≤n≤105```
**输入样例**
5
1 2 2 3 5
**输出样例**
3

思路:
首先是i枚举数组中的每一个位置，在i的某个位置中，j严格<=i,如果出现重复的元素，那么一定是枚举到的当前的a[i]，于是j指针可以开始移动了,只要这个重复的数不从这个"区间"中剔除，那么j就一直往右移动，最多是与i重合，那么while()停止。
抽象成理解的角度就为:
每次维护一个区间，一但出现重复的数，此时将该区间缩减(区间更新)，使区间的头为与a[i](当前的数)重复的第一个数的后面,这样可以就有最优解。


## 1.6 位运算
**模板**
```
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n & -n
```
## 1.7 离散化
**离散化模板**
```c++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

**模板题：区间和**

**题目描述**

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。
现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。
接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。

**输入格式**

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含两个整数 x 和 c。

再接下来 m 行，每行包含两个整数 l 和 r。


**输出格式**

共 m 行，每行输出一个询问中所求的区间内数字和。

**数据范围**
```
−109≤x≤109,
1≤n,m≤105,
−109≤l≤r≤109,
−10000≤c≤10000
```
**输入样例**
```
3 3
1 2
3 6
7 5
1 3
4 6
7 8
```
输出样例
```
8
0
5
```
**思路：如果是较小的数组范围，那可以直接用前缀和。**
```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

const int N = 3e5+10;
typedef pair<int,int> PII;

vector<int> alls;//把需要离散化的下标加进这个数组

vector<PII> add,query;
int a[N],s[N];

int find(int x)
{
    int l = 0,r = alls.size() - 1;
    while(l < r)
    {
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}

int main()
{
    int n,m;
    cin >> n >> m;
    int x,c;
    for(int i = 0;i < n;i++)
    {
        cin >> x >> c;
        add.push_back({x,c});
        alls.push_back(x);//存储该下标，要把下标x离散化
    }
    for(int i = 0;i < m;i++)
    {
        int l,r;
        cin >> l >> r;
        query.push_back({l,r});//

        alls.push_back(l);
        alls.push_back(r);
    }
    //去重
    sort(alls.begin(),alls.end());
    alls.erase(unique(alls.begin(),alls.end()),alls.end());

    for(auto item:add)
    {
        int x = find(item.first);
        a[x]  += item.second;
    }
    //预处理前缀和
    for(int i = 1;i <= alls.size();i++) s[i] = s[i-1] + a[i];

    //处理询问
    for(auto item:query)
    {
        int l = find(item.first),r = find(item.second);
        cout << s[r] - s[l-1] << endl;//输出区间和 
    }
    return 0;
}
```

## 1.8 区间合并	
**合并模板**
```c++
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

**模板题-区间合并**：

给定 n 个区间 [li,ri]，要求合并所有有交集的区间。

注意如果在端点处相交，也算有交集。

输出合并完成后的区间个数。

例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。

**输入格式**

第一行包含整数 n。
接下来 n 行，每行包含两个整数 l 和 r。

**输出格式**

共一行，包含一个整数，表示合并区间完成后的区间个数。

**数据范围**
```
1≤n≤100000,
−10^9≤li≤ri≤10^9
```
**输入样例**：
```
5
1 2
2 4
5 6
7 8
7 9
```
**输出样例**：
```
3
```
**流程**：

1.按照左端点排序，按照左端点从小到大的顺序依次扫描。
2.只有三种关系，merge中就是处理这三种关系去合并。
![20220326204500](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220326204500.png)


# 第二讲 数据结构
主要讲如何用数组去模拟链表、栈与队列。
为什么需要用数组去模拟链表呢？
因为new操作非常慢，一般在笔试题中，链表节点都是十万以上级别，单单是把这100000个节点new出来就已经超时了。
![20220327114630](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220327114630.png)
## 2.1 单链表（定义）
单链表用的最多的就是邻接表，
```C++
//new方式的定义如下：
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int v) { val = v;}
    ListNode(int v = 0) { val = v;}
    ListNode(int v, ListNode* n) { val = v, next = n; }
};

ListNode* head = new ListNode(0);
ListNode* head = new ListNode();
// node1 是一个已经定义好的节点
ListNode* head = new ListNode(0, node1);   // head -> node1
```
**单链表模板**
```c++
//head表示头结点的下标
//e[i] 表示节点i的值
//ne[i] 表示节点i的next指针是多少
//idx 存储当前已经用到了哪个点
int head,e[N],ne[N],idx;

//初始化
void init()
{
    head = -1;
    idx = 0;
}

//将x插到头节点
void add_to_head(int x)
{
    e[idx] = x;//存储x这个值
    ne[idx] = head;//把x节点的指针指向原来head指向的值
    head = idx;//把head指向idx
    idx++; //idx已经被用过了，移到下一位
}
//将x这个点插到下标是k的这个点后面
void add(int k,int x)
{
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}
//将下标是k的点后面的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];
}
```
## 2.2 双链表
**模板**
```c++
int e[N],l[N],r[N],idx;

void init()
{
    //0表示第一个点，1表示第二个点
    r[0] = 1,l[1] = 0;
    idx = 2;
}

//双链表的插入,在下标k的右边插入
//如果想在k的左边插入，就是add(l[k],x),k的左边，就是l[k]的右边
void add(int k,int x)
{
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
}

//删除操作，让这个点的左边节点的右边直接等于这个点的右边,
// 让这个点的右边节点的左边直接等于这个点的左边
void remove(int k)
{
    r[l(k)] = r(k);
    l[r(k)] = l(k);
}
```

## 2.3 栈
栈：先进后出
```c++
// ***************************栈
//stk为栈，tt为栈顶下标
int stk[N],tt;
//插入
stk[++tt] = x;
// 从栈顶弹出一个数
tt -- ;
//判空
if(tt > 0 ) not empty;
else empty;
//栈顶
stk[tt];
```


## 2.4 队列
1.**普通队列**
```c++
//*****************************队列
//hh队头，tt队尾，在队尾插入元素，在队头弹出元素
int q[N],hh,tt = -1;

//插入
q[++tt] = x;
//弹出,把队头的指针往后移动一位，意味着队头弹出了一位
hh ++;
//判断非空
if(hh <= tt) not empty;
else empty;
//取出队头,队尾元素
q[hh],q[tt];
```
2.**循环队列**
```c++
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空
if (hh != tt)
{

}
```

## 2.5 单调栈
**模板题目**
```c++
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```
```c++
#include<iostream>

using namespace std;

const int N = 1e5+10;
int a[N],n;
int stk[N],tt;
/*
//朴素(暴力)做法
for(int i = 0;i < n;i++)//先枚举每个i
    for(int j = i - 1;j >= 0;j--)
        if(a[i] > a[j]) 
        { 
            cout << a[j];
            break;
        }
        else cout << "-1" << ' ';
*/
int main()
{
    ios::sync_with_stdio(false);//加速读入，大概加速100-200ms
    scanf("%d",&n);//scanf printf大概比cin printf快500ms
    for(int i = 0;i < n;i++)
    {
        int x;
        scanf("%d",&x);
        while(tt && stk[tt] >= x) tt--;//满足这个性质(栈不为空且栈顶元素大于插入的i)，则栈顶元素永远不会被用到
        if(tt) printf("%d ",stk[tt]);//如果不满足上面的性质，那栈顶元素就是离i最近且最小的数
        else printf("-1 ");
        
        stk[ ++ tt] = x;//把x插入到栈中
    }
    return 0;
}
```


## 2.6 单调队列
**模板题**--**滑动窗口**

**凡是用单调队列的题，基本上都是滑动窗口。**
```c++
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

## 2.7 KMP算法--字符串匹配算法
**模板题-KMP字符串**

**题目描述**：

给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。
模板串 P 在模式串 S 中多次作为子串出现。求出模板串 P 在模式串 S 中所有出现的位置的起始下标。

**输入格式**

第一行输入整数 N，表示字符串 P 的长度。

第二行输入字符串 P。

第三行输入整数 M，表示字符串 S 的长度。

第四行输入字符串 S。

**输出格式**

共一行，输出所有出现位置的起始下标（下标从 0 开始计数），整数之间用空格隔开。

**数据范围**
```
1≤N≤10^5
1≤M≤10^6
```
**输入样例**：
```
3
aba
5
ababa
```

**输出样例**：
```
0 2
```
朴素做法如下：
![20220328160404](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328160404.png)
**对于模板串这个数组，要预处理出来，我的后缀和前缀相等，这个相等的前缀和后缀最大长度是多少。这就是KMP算法中next[i]数组的含义。**    
![20220328161651](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328161651.png)
![20220328164055](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328164055.png)
![20220328164859](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328164859.png)
![20220328173003](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328173003.png)
![20220328172642](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328172642.png)

完整代码如下：

```c++
#include<iostream>

using namespace std;

const int N = 100010,M = 1000010;

int n,m;
int ne[N];
char p[N],s[M];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;
    //求next过程
    for(int i = 2,j = 0;i <= n;i++)
    {
        while(j && p[i] != p[j+1]) j = ne[j];
        if(p[i] == p[j+1]) j++;
        ne[i] = j;
    }
    //kmp匹配过程
    for(int i = 1,j = 0;i <= m;i++)
    {
        while(j && s[i] != p[j+1]) j = ne[j];
        if(s[i] == p[j+1]) j++;
        if(j == n) 
        {
            //匹配成功,输出起始位置,因为输出下标从0开始计数，所以最后要-1
            printf("%d ",i - n + 1 - 1);
            j = ne[j];//继续匹配下一个子串
        }
    }
    return 0;
}
```
## 2.8 Tire
**Tire树：** 用来高效地存储和查找字符串集合的数据结构。

一般用到Tire树的题目，要么全是大写字母，要么全是小写字母，要么全是0和,字母的类型不会特别多。

Tire树的存储如下：红星代表有单词的结尾。
![20220328202527](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220328202527.png)
Tire树的查找：先从根节点往下查找，如果找到最后正好存在一个结尾标记，那么代表Tire树中有这个字符串。

**代码模板**
```c++
//son存的是每一个点的所有子节点，cnt存的是以当前这个点结尾的单词有多少个，
// idx存的是当前用到的下标，下标是0的点，既是根节点，又是空节点。
int son[N][26],cnt[N],idx;
//插入字符串
void insert(char str[])
{
    int p = 0;
    for(int i = 0;str[i];i++)
    {
        int u = str[i] - 'a';
        if(!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
//查询字符串
int query(char str[])
{
    int p = 0;
    for(int i = 0;str[i];i++)
    {
        int u = str[i] - 'a';
        if(!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

## 2.9 并查集
![20220329101124](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329101124.png)
![20220329122853](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329122853.png)
基本原理：首先用树的形式维护所有的集合。每个集合用一颗树表示。
集合的编号就是树根的编号，我们对每一个节点都存储一下他的父节点，p[x]表示x的父节点。因此判断元素属于哪个集合时，只需要不停的向上找，找到根节点，就可以判断属于哪个集合。

问题1:如何判断树根:if(p[x] == x)

问题2:如何求x的集合编号：while(p[x] != x) x = p[x];//只要x不是树根，就一直往上走。

问题3:如何合并两个集合：加一条边即可。假设px是x的集合编号，py是y的集合编号。令p[x] = y即可;
![20220329104429](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329104429.png)
现在时间复杂度还是比较高的，主要原因还是因为找树根的过程太慢。怎样加速呢？路径压缩优化。

**朴素并查集模板如下：**
```c++
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
```

如果想要动态的知道当前集合元素的个数该怎么做？
模板题-

## 2.10 堆
如何手写一个堆？堆是维护一个数据集合。堆是完全二叉树。除了最后一层节点，所有节点都是非空的。最后一层节点从左到右依次排列的。堆满足小根堆的定义：每一个点的值小于等于左右儿子。那么根节点就是最小值。

**堆要支持哪些操作？**

1.插入一个数

2.求这个集合当中的最小值

3.删除最小值（用最后一个点覆盖掉根节点，去掉最后一个点，down一遍)

4.删除任意一个元素（后面这两个操作STL中的堆无法直接实现)(类似于删除最小值)

5.修改任意一个元素

用一个1维数组可以存下一个堆，根节点是1,左儿子是2x，右儿子是2x+1。
![20220329130721](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329130721.png)

堆的操作：
1.down(x):往下调整。把一个节点往下移。如果把一个值变大了，就把他往下移。
2.up(x):往上调整。把一个节点往上移。如果把一个值变小了，就把他往上移。
刚才的这五个操作，完全可以由这两个操作实现。

![20220329132506](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329132506.png)

这里的下标是从1开始的，比较方便。因为从0开始，2*0=0。
**模板**
```c++
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置,p:下标，h:堆,表示从下标映射到堆。
// hp[k]存储堆中下标是k的点是第几个插入的，表示从堆映射到下标。
int h[N], ph[N], hp[N], Size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;//down操作的核心就是看一下这个点是不是3个点里面的最小值，用t来表示最小值的编号
    //判断是不是左儿子更小一些,如果左儿子更小一些，就让t等于左儿子。
    //如果右儿子更小一些，就让t等于右儿子
    if(u * 2 <= Size && heap[u*2] < heap[t]) t = u * 2;
    if(u * 2 + 1 <= Size && heap[u * 2 + 1] < heap[t]) t = u *2 + 1;
    if(u != t)//说明根节点不是最小的，根节点就要和最小的交换一下，然后递归处理
    {
        // swap(heap[u],heap[t]);
        heap_swap(u,t);
        down(t);
    }
}

void up(int u)
{
    //只要我有父节点，写成u/2,并且我的父节点比当前节点要大的话，就应该交换一下。
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u /= 2;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

## 2.11 哈希表

哈希表是根据关键码值(key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。

哈希表的一个重要问题就是如何解决映射冲突的问题。常用的有两种：开放地址法 和 链地址法。

哈希表的作用：把一个比较复杂的数据结构，映射到比较小的空间，映射到从0-N，N一般是1e5。N最好取质数。比如从$0-10^{-9}->0-10^5$。其实这个映射就是取模，取模N等同于映射到{0,N-1}.

![20220329161501](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329161501.png)

哈希函数怎么写？一般情况下是直接取模即可。就可以把大的值域映射出来。但是可能会有冲突，比如把两个不一样的数，映射成了同样的数。
![20220329164129](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329164129.png)

发生冲突的话要处理冲突，

**1.拉链法**：首先开一个一维数组，来存储所有的哈希值。如果有两个数是冲突的，那我就会在每个槽上，拉一条链，把这些数全部存下来。

![20220329164717](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329164717.png)

**在算法题里，哈希表一般只有添加和查询，没有删除。**

2.开放寻址法：只开一个一维数组，不用开链表。数组长度一般开输入的2-3倍。

那开放寻址法如何处理冲突？添加的话，如果求出来h(x) = k的话，先看数组的k位置上有没有被占用，如果被占用的话，顺移到下一位，直到找到第一个空位为止。

查找的话，如果当前坑位有人并且是x的话，就直接找到了，如果坑位有人但不是x的话，就继续看下一个坑位。如果当前坑位没人，说明x不存在。

删除的话，从前往后找，按照查找的方式来找x，不会把x真的删除，而是把x打一个标记。

哈希表的时间复杂度是O(1)的。

**一般哈希**-**模板**
```c++
(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;//这是为了处理余数是负数的情况。
        e[idx] = x;//以下三行为单链表的插入
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])//遍历哈希表元素,从h[k]开始，h[k]存的是链表头的下标
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```
### 字符串前缀哈希法

![20220330090946](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220330090946.png)

![20220329205325](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220329205325.png)

把所有字符串的前缀映射成哈希值有什么好处？好处就是我们可以用字符串前缀哈希值计算出任意一个子串的哈希值。

**代码模板**
```c++
//思路：分别计算两个子串的哈希值，如果两个子串的哈希值相同，就认为这两个子串是相同的
//很多特别困难的字符串题目（需要思考很久用kmp来做的)，
// 总之，当我们需要快速判断两个字符串是否相等的时候，就都可以用字符串哈希来做
#include<iostream>

using namespace std;
typedef unsigned long long ULL;
const int N = 1e5+10,P = 131;
int n,m;
char str[N];
// h[i]前i个字符的hash值:预处理所有前缀的哈希
// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字
// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突
// 使用场景： 两个字符串的子串是否相同
//核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
//小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果
ULL h[N],p[N];// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

//计算子串 str[l ~ r] 的哈希值
ULL gets(int l,int r)
{
    return h[r] - h[l -1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d%s",&n,&m,str + 1);
    p[0] = 1;// 初始化
    //求字符串前缀的哈希值
    for(int i = 1;i <= n;i++)
    {
        p[i] = p[i - 1]*P;
        h[i] = h[i - 1] * P + str[i];//前缀和求整个字符串的哈希值
    }

    while(m --)
    {
        int l1,r1,l2,r2;
        cin >> l1 >> r1 >> l2 >> r2;
        if(gets(l1,r1) == gets(l2,r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

## 2.12 STL技巧简介

```c++
vector, 变长数组，倍增的思想//要尽量减少vector申请的次数，如果要申请n的空间，那么倍增次数是log(n),平均插入时间是O(1)
    size()  返回元素个数
    empty()  返回是否为空//size和empty函数是所有容器都有的
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []//支持随机寻址
    支持比较运算，按字典序

pair<int, int>//可以存储一个二元组
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，其实就是堆，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义方式：priority_queue<int> heap;
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 map可以像数组一样用，但时间复杂度是 O(logn)，不像数组是O(1);
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```

# 第三讲 搜索与图论

## 3.1 DFS与BFS

空间上DFS更占优势，但是BFS具有最短性。
![20220330150705](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220330150705.png)

凡是算法思路比较奇怪的，需要回溯的，都是用DFS。凡是需要最短，都用BFS。

**n皇后问题**-**DFS代码模板**
```c++
#include <iostream>

using namespace std;

const int N = 20;
char g[N][N];
int n;
bool col[N],dg[N],udg[N];//分别代表列，对角线，反对角线

void dfs(int u)
{
    if(u == n)//到达最后一层，输出排序方案
    {
        for(int i = 0; i < n;i++) puts(g[i]);
        puts("");
        return;
    }
    //对n个位置按行搜索
    for(int i = 0;i < n;i++)
    {
        // 剪枝(对于不满足要求的点，不再继续往下搜索)  
        // udg[n - u + i]，+n是为了保证下标非负
        if(!col[i] && !dg[u + i] && !udg[n-u+i])//如果这个皇后满足条件，就放进空位上
        {
            g[u][i] = 'Q';
            col[i] = dg[u+i] = udg[n-u+i] =true;//表明这行已被用过
            dfs(u + 1);//递归，去放置下一个位置上的点
            col[i] = dg[u+i] = udg[n-u+i] =false;//恢复现场
            g[u][i] = '.';
        }
    }
}

int main()
{
    cin >> n;
    for(int i = 0;i < n;i++)
        for(int j = 0;j < n;j++)
            g[i][j] = '.';
    dfs(0);
    return 0;
}
```
## 走迷宫-BFS代码模板
```c++
 #include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 110;
typedef pair<int,int> PII;
int n,m;
int g[N][N];//用于保存地图
int d[N][N];//用于存每一个点到起点的距离
PII q[N*N];//用于模拟队列

int bfs()
{
    int hh = 0,tt = 0; //初始化队头队尾
    q[0] = {0,0};
    
    memset(d,-1,sizeof d);//初始化d的所有值为-1,表示都没走过
    d[0][0] = 0;//代表起点已经走过了
    //每一次可以往上下左右四个方向拓展，不用写四个判断，可以用向量来表示上下左右移动
    int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1};//顺序：上右下左
    while(hh <= tt)
    {
        auto t = q[hh ++];//每次取出队头元素
        for(int i = 0;i < 4;i++)
        {
            int x = t.first + dx[i],y = t.second + dy[i];
            //在边界内且能走且是第一次走
            if(x >= 0 && x < n && y >=0 && y < m && g[x][y] ==0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1;//更新距离
                q[++ tt] = {x,y}; 
            }
        }
    }
    return d[n-1][m-1];//输出右下角这个点的距离
}

int main()
{
    cin >> n >> m;
    for(int i = 0;i < n;i++)
        for(int j = 0;j < m;j++)
            cin >> g[i][j];
    cout << bfs() << endl;
    return 0;
}
```

DP问题其实是一类没有环的最短路问题。

## 3.2 树与图的遍历：拓扑排序
### 树与图的存储
树是一种无环连通图。所以只讲图的存储。
图的话分成两种。有向图和无向图。对于无向图，每两个连通的点之间，需要建两条边。
为每个点都写一个单链表。每个点的邻居点次序是没关系的。
邻接矩阵用的比较少，因为空间复杂度比较高。

图的邻接表存储如下：插入的话一般在头节点插入。
![20220425173318](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220425173318.png)

### 树与图的遍历
只需要考虑图是怎么遍历的就行
树和图的深度优先遍历和广度优先遍历，其实是一种特殊的深度优先搜索和广度优先搜索。

凡是涉及到树的遍历，链表的遍历，一般都要用到递归的思想，体现到代码就是dfs。

## 3.3 最短路



## 3.4 最小生成树



## 3.5 二分图：染色法、匈牙利算法



# 第四讲 数学知识（基本不考）
## 4.1质数

## 4.2约数

## 4.3欧拉函数

## 4.4快速幂

## 4.5扩展欧几里得算法

## 4.6中国剩余定理

## 4.7高斯消元

## 4.8组合计数

## 4.9容斥原理

## 4.10简单博弈论


# 第五讲 动态规划(考)
DP问题没有模板，都是一些循环，它的核心在于状态表示和状态转移。
所谓的状态就是一个未知数。一般来说背包问题的话就是一个二维的vector f[i][j]。根据具体问题思考，需要用几维的状态来表示。
状态计算：就是指如何一步一步地把每一个状态算出来。状态计算就是状态转移方程。

## 5.1 背包问题

### 5.1.1 01背包问题（特点：每件物品最多能用一次)
![20220503111618](https://raw.githubusercontent.com/Howardcl/MyImage/main/img20220503111618.png)

动态规划的优化都是对代码做一个等价变形。



01背包问题
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。
接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。
输出格式
输出一个整数，表示最大价值。
数据范围
0<N,V≤1000
0<vi,wi≤1000
输入样例：
4 5
1 2
2 4
3 4
4 5
输出样例：
8
二维数组形式：

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n,m;
int v[N],w[N];//v表示体积，w表示价值
int f[N][N];//f表示状态
int main()
{
    cin >> n >> m;//物品个数、背包容量
    for(int i = 1;i <= n;i++)   cin >> v[i] >> w[i];//输入每个物品的体积、价值  注意这里必须从1开始！！！
    for(int i = 1;i <= n;i++)//f[0][0~m]表示考虑0件物品，总体积不超过0~m，故最大价值为0，全局变量以默认初始化，因此从1开始
        for(int j = 0;j <= m;j++)
        {
            f[i][j] = f[i-1][j];//代表不考虑第i件物品，那么价值不变。
            if(j >= v[i])   f[i][j] = max(f[i][j],f[i-1][j-v[i]] + w[i]);
        }
    cout << f[n][m] << endl;
    return 0;
}
```

优化成一维数组形式：

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int n,m;
int v[N],w[N];//v表示体积，w表示价值
int f[N];//一维数组
int main()
{
    cin >> n >> m;//物品个数、背包容量
    for(int i = 1;i <= n;i++)   cin >> v[i] >> w[i];//输入每个物品的体积、价值
    for(int i = 1;i <= n;i++)
        for(int j = m;j >= v[i];j--)//逆序更新
            f[j] = max(f[j],f[j-v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```



### 5.1.2 完全背包问题（特点：每件物品有无限个）

题目描述
有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。
第 i 种物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。
输出格式
输出一个整数，表示最大价值。
数据范围
0<N,V≤1000
0<vi,wi≤1000
输入样例：
4 5
1 2
2 4
3 4
4 5
输出样例：
10

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int n,m;
int v[N],w[N];
int f[N];
int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++)   cin >> v[i] >> w[i];
    for(int i = 1;i <= n;i++)
        for(int j = v[i];j <= m;j++)
            f[j] = max(f[j],f[j-v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```



>>>>>>> 611f204592f465cbd381758319bfc3105358c0d0

### 5.1.3 多重背包问题（特点：每个物品最多有s个)

多重背包问题I
题目描述
有 N 种物品和一个容量是 V 的背包。
第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。
输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。
输出格式
输出一个整数，表示最大价值。
数据范围
0<N,V≤100
0<vi,wi,si≤100
输入样例：
4 5
1 2 3
2 4 1
3 4 3
4 5 2
输出样例：
10
暴力解法：

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int n,m;
int v[N],w[N],s[N];
int f[N][N];
int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n;i++)   cin >> v[i] >> w[i] >> s[i];
    for(int i = 1;i <= n;i++)
        for(int j = 0;j <= m;j++)
            for(int k = 0;k <= s[i] && k * v[i] <= j;k++)
                f[i][j] = max(f[i][j],f[i-1][j-v[i]*k] + w[i] * k);
    cout << f[n][m] << endl;
    return 0;
}
```

多重背包问题 II
题目描述
有 N 种物品和一个容量是 V 的背包。
第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。
输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。
接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。
输出格式
输出一个整数，表示最大价值。
数据范围
0 < N ≤ 1000
0 < V ≤ 2000
0 < vi,wi,si ≤ 2000
提示：
本题考查多重背包的二进制优化方法。
输入样例：
4 5
1 2 3
2 4 1
3 4 3
4 5 2
输出样例：
10

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 12010,M = 2010;//一共有1000个物品，每个物品最多拆分成log2000个物品，故是N的由来
int n,m;
int v[N],w[N];
int f[M];
int main()
{
    cin >> n >> m;
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        int a,b,s;
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s)
        {
            cnt++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if(s > 0)
        {
            cnt++;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }
    n = cnt;//每个数选与不选都能拼凑出任意的数字，这就是2进制的妙用
    for (int i = 1; i <= n; i++)//二进制方式转换成01背包问题
        for(int j = m;j >= v[i];j--)
            f[j] = max(f[j],f[j-v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```




### 5.1.4 分组背包问题(特点：物品有N组，每组物品有若干个，一组里面只能选一个物品)

题目描述
有 N 组物品和一个容量是 V 的背包。
每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。
求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
输出最大价值。
输入格式
第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。
接下来有 N 组数据：
每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值；
输出格式
输出一个整数，表示最大价值。
数据范围
0 < N,V ≤ 100
0 < Si ≤ 100
0 < vij,wij ≤ 100
输入样例：
3 5
2
1 2
2 4
1
3 4
1
4 5
输出样例：
8

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int n,m;
int v[N][N],w[N][N],s[N];
int f[N];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> s[i];
        for(int j = 0;j < s[i];j++)
            cin >> v[i][j] >> w[i][j];
    }
    for(int i = 1; i <= n;i++)
        for(int j = m;j >= 0;j--)//需要从上一状态转移，故从大到小，不太好确定最小值就用了大于等于0，毕竟下面有个if支撑
            for(int k = 0;k < s[i];k++)
                    if(v[i][k] <= j)    f[j] = max(f[j],f[j - v[i][k]] + w[i][k]);
    cout << f[m] << endl;
    return 0;
}
```



## 5.2 线性DP



## 5.3 区间DP



## 5.4 计数类DP



## 5.5 数位统计DP



## 5.6 状态压缩DP



## 5.7 树形DP



## 5.8 记忆化搜索



# 第六讲 贪心

## 6.1 区间问题



## 6.2 Huffman树



## 6.3 排序不等式



## 6.4 绝对值不等式



## 6.5 推公式



# 第七讲 时间复杂度分析